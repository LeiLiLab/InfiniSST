#!/usr/bin/env python3\n\"\"\"\n实时监控PREFILL模式\n追踪为什么会出现重复prefill的问题\n\"\"\"\n\nimport requests\nimport time\nimport json\nfrom collections import defaultdict, deque\nfrom typing import Dict, List, Any\nfrom datetime import datetime\n\nclass PrefillMonitor:\n    \"\"\"监控prefill模式和session行为\"\"\"\n    \n    def __init__(self, server_url: str = \"https://infinisst.ngrok.app\"):\n        self.server_url = server_url\n        self.session_history = defaultdict(list)  # session_id -> [events]\n        self.prefill_events = deque(maxlen=50)  # 最近50个prefill事件\n        self.session_stats = {}  # session统计信息\n        \n    def get_current_state(self) -> Dict[str, Any]:\n        \"\"\"获取当前系统状态\"\"\"\n        try:\n            response = requests.get(f\"{self.server_url}/diagnose\", timeout=5)\n            if response.status_code == 200:\n                return response.json()\n        except Exception as e:\n            print(f\"❌ 获取状态失败: {e}\")\n        return {}\n    \n    def analyze_prefill_pattern(self, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"分析prefill模式\"\"\"\n        queue_stats = data.get('queue_stats', {})\n        detailed_info = queue_stats.get('detailed_queue_info', {})\n        \n        current_time = datetime.now()\n        \n        analysis = {\n            'timestamp': current_time.strftime('%H:%M:%S'),\n            'total_prefill': 0,\n            'total_decode': 0,\n            'active_sessions': queue_stats.get('active_sessions', 0),\n            'suspicious_patterns': [],\n            'session_analysis': []\n        }\n        \n        # 统计队列情况\n        for gpu_id, info in detailed_info.items():\n            prefill_count = info.get('prefill_queue_size', 0)\n            decode_count = info.get('decode_queue_size', 0)\n            analysis['total_prefill'] += prefill_count\n            analysis['total_decode'] += decode_count\n        \n        # 检测可疑模式\n        if analysis['total_prefill'] > 1:\n            analysis['suspicious_patterns'].append(\n                f\"🚨 多个PREFILL同时存在 ({analysis['total_prefill']} 个)\"\n            )\n            \n            # 记录prefill事件\n            prefill_event = {\n                'time': current_time,\n                'count': analysis['total_prefill'],\n                'sessions': analysis['active_sessions']\n            }\n            self.prefill_events.append(prefill_event)\n        \n        if analysis['total_prefill'] > analysis['active_sessions']:\n            analysis['suspicious_patterns'].append(\n                f\"🚨 PREFILL数量 ({analysis['total_prefill']}) > Session数量 ({analysis['active_sessions']})\"\n            )\n        \n        if analysis['total_prefill'] == 0 and analysis['total_decode'] == 0 and analysis['active_sessions'] > 0:\n            analysis['suspicious_patterns'].append(\n                f\"🚨 有{analysis['active_sessions']}个活跃Session但队列为空\"\n            )\n        \n        return analysis\n    \n    def detect_patterns_over_time(self) -> List[str]:\n        \"\"\"检测时间模式\"\"\"\n        patterns = []\n        \n        if len(self.prefill_events) >= 3:\n            # 检查是否有快速重复的prefill\n            recent_events = list(self.prefill_events)[-3:]\n            time_diffs = []\n            \n            for i in range(1, len(recent_events)):\n                diff = (recent_events[i]['time'] - recent_events[i-1]['time']).total_seconds()\n                time_diffs.append(diff)\n            \n            avg_interval = sum(time_diffs) / len(time_diffs)\n            \n            if avg_interval < 5:  # 5秒内重复\n                patterns.append(f\"⚠️ 检测到快速重复prefill (平均间隔: {avg_interval:.1f}s)\")\n                patterns.append(\"   可能原因: 前端重复发送或WebSocket重连\")\n            \n            # 检查prefill数量趋势\n            counts = [event['count'] for event in recent_events]\n            if all(c > 1 for c in counts):\n                patterns.append(f\"⚠️ 持续的多prefill状态 (数量: {counts})\")\n                patterns.append(\"   可能原因: 并发竞争或session状态管理错误\")\n        \n        return patterns\n    \n    def print_real_time_analysis(self, analysis: Dict[str, Any]):\n        \"\"\"打印实时分析结果\"\"\"\n        print(f\"\\n📊 [{analysis['timestamp']}] 实时监控:\")\n        print(f\"   队列状态: {analysis['total_prefill']}P + {analysis['total_decode']}D\")\n        print(f\"   活跃Sessions: {analysis['active_sessions']}\")\n        \n        if analysis['suspicious_patterns']:\n            print(\"   🚨 可疑模式:\")\n            for pattern in analysis['suspicious_patterns']:\n                print(f\"     {pattern}\")\n        else:\n            print(\"   ✅ 正常状态\")\n        \n        # 显示时间模式分析\n        time_patterns = self.detect_patterns_over_time()\n        if time_patterns:\n            print(\"   🕒 时间模式分析:\")\n            for pattern in time_patterns:\n                print(f\"     {pattern}\")\n    \n    def monitor_continuous(self, interval: int = 3, duration: int = 60):\n        \"\"\"持续监控指定时间\"\"\"\n        print(f\"🔍 开始持续监控 (间隔: {interval}s, 持续: {duration}s)\")\n        print(\"=\" * 60)\n        \n        start_time = time.time()\n        check_count = 0\n        \n        while time.time() - start_time < duration:\n            try:\n                data = self.get_current_state()\n                if data:\n                    analysis = self.analyze_prefill_pattern(data)\n                    self.print_real_time_analysis(analysis)\n                    \n                    check_count += 1\n                    \n                    # 每10次检查输出一次统计摘要\n                    if check_count % 10 == 0:\n                        self.print_summary()\n                \n                time.sleep(interval)\n                \n            except KeyboardInterrupt:\n                print(\"\\n⏹️ 监控已停止\")\n                break\n            except Exception as e:\n                print(f\"❌ 监控错误: {e}\")\n                time.sleep(interval)\n        \n        print(f\"\\n✅ 监控完成 (共检查 {check_count} 次)\")\n        self.print_final_summary()\n    \n    def print_summary(self):\n        \"\"\"打印阶段性摘要\"\"\"\n        if not self.prefill_events:\n            return\n        \n        print(\"\\n📈 阶段性摘要:\")\n        print(f\"   检测到 {len(self.prefill_events)} 次多prefill事件\")\n        \n        if len(self.prefill_events) >= 2:\n            intervals = []\n            events = list(self.prefill_events)\n            for i in range(1, len(events)):\n                interval = (events[i]['time'] - events[i-1]['time']).total_seconds()\n                intervals.append(interval)\n            \n            avg_interval = sum(intervals) / len(intervals)\n            min_interval = min(intervals)\n            print(f\"   平均间隔: {avg_interval:.1f}s, 最短间隔: {min_interval:.1f}s\")\n    \n    def print_final_summary(self):\n        \"\"\"打印最终总结\"\"\"\n        print(\"\\n📋 监控总结:\")\n        print(\"=\" * 40)\n        \n        if not self.prefill_events:\n            print(\"✅ 未检测到多prefill问题\")\n            return\n        \n        print(f\"🚨 检测到 {len(self.prefill_events)} 次多prefill事件\")\n        \n        # 分析频率\n        events = list(self.prefill_events)\n        if len(events) >= 2:\n            total_time = (events[-1]['time'] - events[0]['time']).total_seconds()\n            frequency = len(events) / (total_time / 60)  # 每分钟频率\n            print(f\"📊 平均频率: {frequency:.1f} 次/分钟\")\n        \n        # 分析prefill数量分布\n        counts = [event['count'] for event in events]\n        max_count = max(counts)\n        avg_count = sum(counts) / len(counts)\n        print(f\"📊 PREFILL数量: 平均 {avg_count:.1f}, 最高 {max_count}\")\n        \n        # 建议\n        print(\"\\n💡 建议:\")\n        if len(events) > 10:\n            print(\"   1. 检查前端是否重复发送初始音频数据\")\n            print(\"   2. 检查WebSocket连接稳定性\")\n            print(\"   3. 考虑在前端添加去重逻辑\")\n        else:\n            print(\"   1. 问题不严重，可能是偶发性的\")\n            print(\"   2. 继续观察是否有规律性\")\n\ndef main():\n    import argparse\n    \n    parser = argparse.ArgumentParser(description=\"监控PREFILL重复模式\")\n    parser.add_argument(\"--server\", default=\"https://infinisst.ngrok.app\", help=\"服务器URL\")\n    parser.add_argument(\"--interval\", type=int, default=3, help=\"检查间隔(秒)\")\n    parser.add_argument(\"--duration\", type=int, default=60, help=\"监控持续时间(秒)\")\n    parser.add_argument(\"--single\", action=\"store_true\", help=\"只检查一次\")\n    \n    args = parser.parse_args()\n    \n    monitor = PrefillMonitor(args.server)\n    \n    if args.single:\n        data = monitor.get_current_state()\n        if data:\n            analysis = monitor.analyze_prefill_pattern(data)\n            monitor.print_real_time_analysis(analysis)\n    else:\n        monitor.monitor_continuous(args.interval, args.duration)\n\nif __name__ == \"__main__\":\n    main() 