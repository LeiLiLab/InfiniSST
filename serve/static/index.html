<!DOCTYPE html>
<html>
<head>
    <title>InfiniSST Translation Demo</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            -webkit-app-region: drag; /* ä½¿headerå¯æ‹–æ‹½ */
            cursor: move;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            -webkit-app-region: no-drag; /* æ ‡é¢˜æ–‡å­—ä¸å¯æ‹–æ‹½ï¼Œé¿å…é€‰æ‹©å†²çª */
        }

        .header p {
            font-size: 1.1rem;
            color: #a0a0a0;
            font-weight: 300;
            -webkit-app-region: no-drag; /* å‰¯æ ‡é¢˜ä¸å¯æ‹–æ‹½ */
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            -webkit-app-region: no-drag; /* ä¸»é¢æ¿å†…å®¹ä¸å¯æ‹–æ‹½ */
        }

        .controls-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 2fr;
            gap: 20px;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .button-row {
            display: flex;
            gap: 12px;
            align-items: stretch; /* ç¡®ä¿æŒ‰é’®ä¸selecté«˜åº¦ä¸€è‡´ */
        }

        .button-row .btn {
            flex: 1;
            min-width: 120px;
        }

        .control-group.buttons-group {
            justify-content: flex-end;
            align-self: stretch; /* æ‹‰ä¼¸åˆ°ä¸å…¶ä»–æ§ä»¶ç›¸åŒé«˜åº¦ */
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* å†…å®¹åº•éƒ¨å¯¹é½ */
        }

        /* Electronç‰¹å®šçš„ä¿®å¤ */
        .electron-app .control-group.buttons-group {
            margin-top: 20px !important; /* ç»§ç»­å¾€ä¸‹è°ƒæ•´ */
            align-self: flex-start !important;
        }

        .control-group label {
            font-size: 0.9rem;
            color: #a0a0a0;
            font-weight: 500;
        }

        select, .btn {
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 48px; /* ç¡®ä¿ç»Ÿä¸€é«˜åº¦ */
            box-sizing: border-box;
        }

        select:focus, .btn:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2);
        }

        .btn {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            border: none;
            font-weight: 600;
            min-width: 140px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .input-section {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 16px;
        }

        .input-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .input-item.youtube-section {
            flex-direction: row;
            gap: 15px;
            align-items: center;
        }

        .upload-btn, .record-btn {
            padding: 16px 24px;
            border: none;
            border-radius: 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 56px;
            white-space: nowrap;
            width: 100%;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .record-btn {
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .record-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 87, 108, 0.4);
        }

        .record-btn.recording {
            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0); }
        }

        .play-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.4);
        }

        .url-input {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            min-height: 56px;
        }

        .url-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2);
        }

        .url-input::placeholder {
            color: #888;
        }

        .video-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-placeholder {
            color: #666;
            font-size: 1.2rem;
            text-align: center;
        }

        audio, video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Floating Translation Panel */
        .translation-panel {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 60px);
            max-width: 1160px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: all 0.3s ease;
            cursor: move;
            user-select: none;
        }

        .translation-panel.minimized {
            height: 60px;
            overflow: hidden;
        }

        .translation-panel.dragging {
            transition: none;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7);
        }

        .translation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .translation-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .panel-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .status-indicator {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-indicator.ready {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-indicator.processing {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .status-indicator.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .panel-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .panel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .panel-btn svg {
            width: 12px;
            height: 12px;
        }

        .panel-btn.reset-btn {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            width: auto;
            height: auto;
        }

        .panel-btn.reset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
        }

        .panel-btn.reset-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .translation-content {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .translation-output {
            min-height: 120px;
            max-height: 260px; /* æ·»åŠ æœ€å¤§é«˜åº¦é™åˆ¶ */
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 1rem;
            line-height: 1.5;
            white-space: pre-wrap;
            color: #ffffff;
            overflow-y: auto; /* å½“å†…å®¹è¶…å‡ºæ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            overflow-x: hidden; /* éšè—æ¨ªå‘æ»šåŠ¨æ¡ */
            /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(255, 255, 255, 0.1);
        }

        /* Webkitæµè§ˆå™¨çš„æ»šåŠ¨æ¡æ ·å¼ */
        .translation-output::-webkit-scrollbar {
            width: 6px;
        }

        .translation-output::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .translation-output::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .translation-output::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .volume-indicator {
            margin-top: 15px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .volume-level {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4caf50 0%, #8bc34a 50%, #ffeb3b 75%, #ff9800 90%, #f44336 100%);
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        .hidden {
            display: none !important;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            cursor: pointer;
        }

        .mic-status {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #a0a0a0;
            text-align: center;
        }

        @media (max-width: 1024px) {
            .input-section {
                grid-template-columns: 1fr;
                gap: 15px;
                text-align: center;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-panel {
                padding: 20px;
            }

            .translation-panel {
                left: 15px;
                right: 15px;
                bottom: 15px;
                width: auto;
                max-width: none;
                transform: none;
            }
        }

        /* Icon styles */
        .icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4facfe;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Resize handle */
        .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nw-resize;
            background: linear-gradient(-45deg, transparent 0%, transparent 40%, rgba(255,255,255,0.1) 40%, rgba(255,255,255,0.1) 60%, transparent 60%);
        }

        /* Toasté€šçŸ¥ç³»ç»Ÿå·²ç§»é™¤ */

        /* çŠ¶æ€æ åœ¨Electronç¯å¢ƒä¸­çš„æ ·å¼è°ƒæ•´ */
        .electron-status-bar {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .electron-status-bar.ready {
            border-left: 4px solid #4caf50;
        }

        .electron-status-bar.processing {
            border-left: 4px solid #ff9800;
        }

        .electron-status-bar.error {
            border-left: 4px solid #f44336;
        }

        .electron-status-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .electron-status-icon.ready {
            background: #4caf50;
        }

        .electron-status-icon.processing {
            background: #ff9800;
            animation: pulse 2s infinite;
        }

        .electron-status-icon.error {
            background: #f44336;
        }
    </style>
</head>
<body>
    <!-- Electronä¸“ç”¨éŸ³é¢‘å¤„ç†å™¨ -->
    <script src="/static/electron-audio-fix.js"></script>
    
    <!-- Toasté€šçŸ¥å®¹å™¨å·²ç§»é™¤ -->
    
    <div class="container">
        <div class="header">
            <h1>InfiniSST Translation Demo</h1>
            <p>Simultaneous end-to-end speech translation powered by LLM</p>
        </div>

        <div class="main-panel">
            <!-- Model Configuration -->
            <div class="controls-section">
                <div class="control-group">
                    <label>Model</label>
                    <select id="agentType">
                        <option value="InfiniSST">InfiniSST</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Language Pair</label>
                    <select id="languagePair">
                        <option value="English -> Chinese">English â†’ Chinese</option>
                        <option value="English -> Italian">English â†’ Italian</option>
<!--                        TODO æš‚æ—¶æ²¡è®­ç»ƒ-->
<!--                        <option value="English -> German">English â†’ German</option>-->
<!--                        <option value="English -> Spanish">English â†’ Spanish</option>-->
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Latency</label>
                    <select id="latencyMultiplier">
                        <option value="1">1x (Fastest)</option>
                        <option value="2" selected>2x (Default)</option>
                        <option value="3">3x (More Accurate)</option>
                        <option value="4">4x (Most Accurate)</option>
                    </select>
                </div>
                
                <div class="control-group buttons-group">
                    <div class="button-row">
                        <button id="loadModel" class="btn">Load Model</button>
                        <button id="updateLatency" class="btn" disabled>Update Latency</button>
                    </div>
                </div>
            </div>

            <!-- Audio Input Section -->
            <div class="input-section">
                <div class="input-item">
                    <button class="upload-btn" type="button" id="uploadBtn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                        </svg>
                        Upload Video/Audio
                    </button>
                    <input type="file" id="audioFile" class="file-input" accept="audio/*,video/*" />
                </div>
                
                <div class="input-item youtube-section">
                    <input type="url" id="youtubeUrl" class="url-input" placeholder="https://www.youtube.com/watch?v=..." />
                    <button id="playBtn" class="play-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                        </svg>
                    </button>
                </div>
                
                <div class="input-item">
                    <button id="toggleMic" class="record-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                        </svg>
                        Record Audio
                    </button>
                </div>
            </div>

            <!-- Microphone Status -->
            <div id="micStatus" class="mic-status"></div>
            <div class="volume-indicator hidden" id="volumeIndicator">
                <div id="volumeLevel" class="volume-level"></div>
            </div>

            <!-- Video/Audio Player -->
            <div class="video-section">
                <div class="video-container" id="mediaContainer">
                    <div class="video-placeholder">
                        <p>Upload a video/audio file or enter a YouTube URL to begin</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Translation Panel -->
    <div id="translationPanel" class="translation-panel">
        <div class="translation-header" id="panelHeader">
            <div class="header-left">
                <h3>Ready to translate</h3>
                <div id="statusIndicator" class="status-indicator ready">
                    <div class="loading hidden" id="loadingSpinner"></div>
                    <span id="statusText">Ready</span>
                </div>
            </div>
            <div class="panel-controls">
                <button id="resetTranslation" class="panel-btn reset-btn" disabled>Reset</button>
                <button id="minimizeBtn" class="panel-btn" title="Minimize">
                    <svg viewBox="0 0 24 24">
                        <path d="M19,13H5V11H19V13Z"/>
                    </svg>
                </button>
                <button id="closeBtn" class="panel-btn" title="Close">
                    <svg viewBox="0 0 24 24">
                        <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="translation-content" id="translationContent">
            <div id="translationOutput" class="translation-output">
                Translation will appear here...
            </div>
        </div>
        <div class="resize-handle" id="resizeHandle"></div>
    </div>

    <script>
        let ws = null;
        let sessionId = null;
        let audioContext = null;
        let audioSource = null;
        let processor = null;
        const segmentSize = 4096;
        const targetSampleRate = 16000;
        const baseChunkSize = 960 * 16;
        let currentLatencyMultiplier = 2;
        let audioBuffer = new Float32Array();
        let resampledBuffer = new Float32Array();
        let firstChunkSent = false;
        let translationPaused = true;
        
        const PRE_BUFFER_DELAY_MS = 300;
        let idleTimer = null;
        const IDLE_TIMEOUT = 5 * 60 * 1000;
        let pingInterval = null;
        const PING_INTERVAL = 5000;
        let deleteRetryInterval = null;
        const SESSION_DELETE_RETRY_INTERVAL = 10000;
        const QUEUE_CHECK_INTERVAL = 2000;
        let queueCheckInterval = null;
        let isQueued = false;
        let clientId = null;
        
        let translationInitialized = false;
        let micStream = null;
        let micRecorder = null;
        let isMicRecording = false;
        let audioElementConnected = false;
        let currentMediaElement = null;
        let audioProcessingActive = false; // å…¨å±€éŸ³é¢‘å¤„ç†çŠ¶æ€æ ‡å¿—

        // Panel dragging variables
        let isDragging = false;
        let isResizing = false;
        let dragOffset = { x: 0, y: 0 };
        let isMinimized = false;

        // UI Elements
        const agentType = document.getElementById('agentType');
        const languagePair = document.getElementById('languagePair');
        const latencyMultiplier = document.getElementById('latencyMultiplier');
        const loadModel = document.getElementById('loadModel');
        const updateLatency = document.getElementById('updateLatency');
        const audioFile = document.getElementById('audioFile');
        const youtubeUrl = document.getElementById('youtubeUrl');
        const playBtn = document.getElementById('playBtn');
        const resetTranslation = document.getElementById('resetTranslation');
        const translationOutput = document.getElementById('translationOutput');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const toggleMic = document.getElementById('toggleMic');
        const micStatus = document.getElementById('micStatus');
        const volumeLevel = document.getElementById('volumeLevel');
        const volumeIndicator = document.getElementById('volumeIndicator');
        const mediaContainer = document.getElementById('mediaContainer');
        const uploadBtn = document.getElementById('uploadBtn');
        
        // Panel elements
        const translationPanel = document.getElementById('translationPanel');
        const panelHeader = document.getElementById('panelHeader');
        const translationContent = document.getElementById('translationContent');
        const minimizeBtn = document.getElementById('minimizeBtn');
        const closeBtn = document.getElementById('closeBtn');
        const resizeHandle = document.getElementById('resizeHandle');

        // Electron é›†æˆæ£€æµ‹å’Œåˆå§‹åŒ–
        let isElectron = false;
        let serverConfig = null; // æ·»åŠ æœåŠ¡å™¨é…ç½®
        let translationWindowShown = false; // è·Ÿè¸ªç¿»è¯‘çª—å£çŠ¶æ€
        let electronAudioProcessor = null; // Electronä¸“ç”¨éŸ³é¢‘å¤„ç†å™¨

        // Electronä¸“ç”¨æ§åˆ¶é¢æ¿å˜é‡å£°æ˜
        let electronControlPanel = null;
        let translationStyleSettings = {
            fontSize: 14,
            backgroundOpacity: 95,
            textColor: '#ffffff'
        };

        // Electronä¸“ç”¨æ§åˆ¶é¢æ¿å‡½æ•°
        function createElectronControlPanel() {
            if (electronControlPanel) return;

            // åˆ›å»ºæ§åˆ¶é¢æ¿
            electronControlPanel = document.createElement('div');
            electronControlPanel.id = 'electronControlPanel';
            electronControlPanel.innerHTML = `
                <div class="electron-panel-header">
                    <h3>Translation Window Control</h3>
                    <button class="panel-toggle-btn" id="panelToggleBtn">âˆ’</button>
                </div>
                <div class="electron-panel-content" id="electronPanelContent">
                    <!-- ElectronçŠ¶æ€æ  -->
                    <div class="electron-status-bar ready" id="electronStatusBar">
                        <div class="electron-status-icon ready" id="electronStatusIcon"></div>
                        <div class="electron-status-text" id="electronStatusText">Ready - Load model</div>
                    </div>
                    
                    <div class="control-group">
                        <label>Font Size</label>
                        <div class="font-controls">
                            <button class="control-btn" id="electronFontDecrease">Aâˆ’</button>
                            <span class="font-size-display" id="electronFontSize">14px</span>
                            <button class="control-btn" id="electronFontIncrease">A+</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Background Opacity</label>
                        <div class="opacity-controls">
                            <input type="range" id="opacitySlider" min="0" max="100" value="95" class="opacity-slider">
                            <span class="opacity-display" id="opacityDisplay">95%</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Text Color</label>
                        <div class="text-color-controls">
                            <button class="color-btn active" id="whiteTextBtn" data-color="#ffffff">White</button>
                            <button class="color-btn" id="blackTextBtn" data-color="#000000">Black</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Window Control</label>
                        <div class="window-controls">
                            <button class="control-btn" id="electronShowWindow">Show Window</button>
                            <button class="control-btn" id="electronHideWindow">Hide Window</button>
                            <button class="control-btn reset-btn" id="electronResetTranslation">Reset Translation</button>
                        </div>
                    </div>
                </div>
            `;

            // æ·»åŠ æ ·å¼
            const style = document.createElement('style');
            style.textContent = `
                #electronControlPanel {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    width: 280px;
                    background: rgba(0, 0, 0, 0.9);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 16px;
                    padding: 0;
                    z-index: 2000;
                    backdrop-filter: blur(20px);
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                    transition: all 0.3s ease;
                    -webkit-app-region: no-drag; /* æ§åˆ¶é¢æ¿ä¸å¯æ‹–æ‹½ */
                }

                .electron-panel-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 16px 20px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 16px 16px 0 0;
                }

                .electron-panel-header h3 {
                    color: #ffffff;
                    font-size: 1rem;
                    font-weight: 600;
                    margin: 0;
                }

                .panel-toggle-btn {
                    width: 24px;
                    height: 24px;
                    border: none;
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 6px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s ease;
                }

                .panel-toggle-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                }

                .electron-panel-content {
                    padding: 20px;
                    transition: all 0.3s ease;
                    overflow: hidden;
                }

                #electronControlPanel.collapsed .electron-panel-content {
                    max-height: 0;
                    padding: 0 20px;
                }

                .control-group {
                    margin-bottom: 20px;
                }

                .control-group:last-child {
                    margin-bottom: 0;
                }

                .control-group label {
                    display: block;
                    color: #a0a0a0;
                    font-size: 0.9rem;
                    font-weight: 500;
                    margin-bottom: 8px;
                }

                .font-controls {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .font-controls .control-btn {
                    width: 32px;
                    height: 28px;
                    border: none;
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.8rem;
                    font-weight: bold;
                    transition: all 0.2s ease;
                }

                .font-controls .control-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                .font-size-display {
                    color: #ffffff;
                    font-size: 0.9rem;
                    font-weight: 600;
                    min-width: 40px;
                    text-align: center;
                }

                .opacity-controls {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                }

                .opacity-slider {
                    flex: 1;
                    height: 6px;
                    -webkit-appearance: none;
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 3px;
                    outline: none;
                }

                .opacity-slider::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    width: 16px;
                    height: 16px;
                    background: #4facfe;
                    border-radius: 50%;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }

                .opacity-slider::-webkit-slider-thumb:hover {
                    transform: scale(1.2);
                }

                .opacity-display {
                    color: #ffffff;
                    font-size: 0.9rem;
                    font-weight: 600;
                    min-width: 40px;
                    text-align: center;
                }

                .text-color-controls {
                    display: flex;
                    gap: 8px;
                }

                .color-btn {
                    flex: 1;
                    padding: 8px 12px;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.8rem;
                    font-weight: 600;
                    transition: all 0.2s ease;
                }

                .color-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                .color-btn.active {
                    background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
                    border-color: #4facfe;
                }

                .window-controls {
                    display: flex;
                    gap: 8px;
                    flex-wrap: wrap;
                }

                .window-controls .control-btn {
                    flex: 1;
                    min-width: 70px;
                    padding: 8px 12px;
                    border: none;
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.8rem;
                    font-weight: 600;
                    transition: all 0.2s ease;
                }

                .window-controls .control-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                .window-controls .reset-btn {
                    background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
                    flex: 1;
                    min-width: 90px;
                    font-size: 0.75rem;
                }

                .window-controls .reset-btn:hover {
                    background: linear-gradient(45deg, #369ef7 0%, #00d4fe 100%);
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(electronControlPanel);

            // ç»‘å®šäº‹ä»¶
            setupElectronControlEvents();
        }

        function setupElectronControlEvents() {
            // é¢æ¿æ”¶ç¼©/å±•å¼€
            const panelToggleBtn = document.getElementById('panelToggleBtn');
            panelToggleBtn.addEventListener('click', () => {
                electronControlPanel.classList.toggle('collapsed');
                panelToggleBtn.textContent = electronControlPanel.classList.contains('collapsed') ? '+' : 'âˆ’';
            });

            // å­—ä½“å¤§å°æ§åˆ¶
            const fontDecreaseBtn = document.getElementById('electronFontDecrease');
            const fontIncreaseBtn = document.getElementById('electronFontIncrease');
            const fontSizeDisplay = document.getElementById('electronFontSize');

            fontDecreaseBtn.addEventListener('click', () => {
                translationStyleSettings.fontSize = Math.max(10, translationStyleSettings.fontSize - 2);
                updateTranslationStyle();
                fontSizeDisplay.textContent = translationStyleSettings.fontSize + 'px';
            });

            fontIncreaseBtn.addEventListener('click', () => {
                translationStyleSettings.fontSize = Math.min(24, translationStyleSettings.fontSize + 2);
                updateTranslationStyle();
                fontSizeDisplay.textContent = translationStyleSettings.fontSize + 'px';
            });

            // é€æ˜åº¦æ§åˆ¶
            const opacitySlider = document.getElementById('opacitySlider');
            const opacityDisplay = document.getElementById('opacityDisplay');

            opacitySlider.addEventListener('input', (e) => {
                translationStyleSettings.backgroundOpacity = parseInt(e.target.value);
                updateTranslationStyle();
                opacityDisplay.textContent = translationStyleSettings.backgroundOpacity + '%';
            });

            // æ–‡å­—é¢œè‰²æ§åˆ¶
            const colorBtns = document.querySelectorAll('.color-btn');
            colorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    colorBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    translationStyleSettings.textColor = btn.dataset.color;
                    updateTranslationStyle();
                });
            });

            // çª—å£æ§åˆ¶
            const showWindowBtn = document.getElementById('electronShowWindow');
            const hideWindowBtn = document.getElementById('electronHideWindow');
            const resetTranslationBtn = document.getElementById('electronResetTranslation');

            showWindowBtn.addEventListener('click', () => {
                showElectronTranslationWindow();
            });

            hideWindowBtn.addEventListener('click', () => {
                if (window.electronAPI && window.electronAPI.hideTranslationWindow) {
                    window.electronAPI.hideTranslationWindow();
                }
            });

            resetTranslationBtn.addEventListener('click', async () => {
                if (typeof resetTranslationFromElectron === 'function') {
                    await resetTranslationFromElectron();
                }
            });
        }

        function updateTranslationStyle() {
            if (window.electronAPI && window.electronAPI.updateTranslationStyle) {
                window.electronAPI.updateTranslationStyle(translationStyleSettings);
            }
        }

        // æ£€æµ‹æ˜¯å¦åœ¨ Electron ç¯å¢ƒä¸­è¿è¡Œ
        console.log('ğŸ” Environment detection:', {
            hasWindow: typeof window !== 'undefined',
            hasElectronAPI: typeof window !== 'undefined' && !!window.electronAPI,
            hasElectronAudioProcessor: typeof window !== 'undefined' && !!window.ElectronAudioProcessor
        });
        
        if (typeof window !== 'undefined' && window.electronAPI) {
            isElectron = true;
            console.log('âœ… Electron environment confirmed');
            
            // åœ¨Electronç¯å¢ƒä¸­éšè—ä¸»çª—å£çš„ç¿»è¯‘é¢æ¿
            const mainTranslationPanel = document.getElementById('translationPanel');
            if (mainTranslationPanel) {
                mainTranslationPanel.style.display = 'none';
            }
            
            // ä»å½“å‰URLè·å–æœåŠ¡å™¨é…ç½®
            const currentUrl = new URL(window.location.href);
            serverConfig = {
                protocol: currentUrl.protocol.replace(':', ''),
                host: currentUrl.hostname,
                port: currentUrl.port || (currentUrl.protocol === 'https:' ? '443' : '80')
            };
            
            console.log('Electron environment detected, server config:', serverConfig);
            
            // ç­‰å¾…ElectronAudioProcessoråŠ è½½å®Œæˆ
            const checkElectronAudioProcessor = () => {
                if (window.ElectronAudioProcessor) {
                    console.log('âœ… ElectronAudioProcessor is now available');
                } else {
                    console.log('â³ Waiting for ElectronAudioProcessor to load...');
                    setTimeout(checkElectronAudioProcessor, 100);
                }
            };
            checkElectronAudioProcessor();
            
            // ç«‹å³æ˜¾ç¤ºç‹¬ç«‹ç¿»è¯‘çª—å£
            setTimeout(() => {
                showElectronTranslationWindow();
                updateElectronStatus('Ready - Load model', 'ready');
            }, 500);
            
            // åˆ›å»ºElectronä¸“ç”¨æ§åˆ¶é¢æ¿
            createElectronControlPanel();
            
            // æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯
            const versionInfo = document.getElementById('versionInfo');
            if (versionInfo && window.electronAPI.versions) {
                versionInfo.innerHTML = `
                    Electron: ${window.electronAPI.versions.electron}<br>
                    Node: ${window.electronAPI.versions.node}<br>
                    Chrome: ${window.electronAPI.versions.chrome}
                `;
                versionInfo.classList.remove('hidden');
            }
            
            // ç›‘å¬èœå•æ–‡ä»¶æ‰“å¼€äº‹ä»¶
            window.electronAPI.onMenuOpenFile(() => {
                // è§¦å‘æ–‡ä»¶é€‰æ‹©å™¨
                if (audioFile) {
                    audioFile.click();
                }
            });
        }

        // Electronç¿»è¯‘çª—å£è¾…åŠ©å‡½æ•°
        function showElectronTranslationWindow() {
            if (isElectron) {
                try {
                    window.electronAPI.showTranslationWindow();
                    translationWindowShown = true;
                    console.log('Electron translation window shown');
                } catch (error) {
                    console.error('Error showing translation window:', error);
                }
            }
        }

        function updateElectronTranslation(text) {
            if (isElectron) {
                // ç¡®ä¿ç¿»è¯‘çª—å£å·²æ˜¾ç¤º
                if (!translationWindowShown) {
                    showElectronTranslationWindow();
                }
                // å‘é€ç¿»è¯‘æ›´æ–°
                try {
                    window.electronAPI.updateTranslation({ text: text });
                    console.log('Translation updated to Electron window:', text.substring(0, 50) + '...');
                } catch (error) {
                    console.error('Error updating Electron translation:', error);
                }
            }
        }

        function updateElectronStatus(text, type = 'ready') {
            if (isElectron) {
                // æ›´æ–°Electronæ§åˆ¶é¢æ¿ä¸­çš„çŠ¶æ€æ 
                updateElectronStatusBar(text, type);
                
                // å‘é€åˆ°ç‹¬ç«‹ç¿»è¯‘çª—å£ï¼ˆä½†çª—å£ä¸å†æ˜¾ç¤ºçŠ¶æ€ï¼‰
                try {
                    window.electronAPI.updateTranslationStatus({ text: text, type: type });
                    console.log('Status updated to Electron window:', text, type);
                } catch (error) {
                    console.error('Error updating Electron status:', error);
                }
            }
        }

        // è·å–WebSocket URLçš„è¾…åŠ©å‡½æ•°
        function getWebSocketUrl(sessionId) {
            if (isElectron && serverConfig) {
                // åœ¨Electronç¯å¢ƒä¸­ï¼Œä½¿ç”¨æœåŠ¡å™¨é…ç½®æ„é€ WebSocket URL
                const wsProtocol = serverConfig.protocol === 'https' ? 'wss' : 'ws';
                const port = serverConfig.port ? `:${serverConfig.port}` : '';
                return `${wsProtocol}://${serverConfig.host}${port}/wss/${sessionId}`;
            } else {
                // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­ï¼Œä½¿ç”¨å½“å‰é¡µé¢çš„åè®®å’Œä¸»æœº
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                return `${protocol}//${window.location.host}/wss/${sessionId}`;
            }
        }

        // Panel drag functionality
        function initializePanelDragging() {
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œé˜²æ­¢åœ¨Electronç¯å¢ƒä¸‹å‡ºé”™
            if (panelHeader) {
                panelHeader.addEventListener('mousedown', startDragging);
            }
            if (resizeHandle) {
                resizeHandle.addEventListener('mousedown', startResizing);
            }
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', stopDragging);

            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', toggleMinimize);
            }
            if (closeBtn) {
                closeBtn.addEventListener('click', closePanel);
            }
        }

        function startDragging(e) {
            if (e.target === minimizeBtn || e.target === closeBtn || e.target.closest('.panel-btn')) {
                return;
            }
            
            if (!translationPanel) return;
            
            isDragging = true;
            translationPanel.classList.add('dragging');
            
            const rect = translationPanel.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            e.preventDefault();
        }

        function startResizing(e) {
            isResizing = true;
            e.preventDefault();
            e.stopPropagation();
        }

        function handleMouseMove(e) {
            if (isDragging && translationPanel) {
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                // Keep panel within viewport bounds
                const maxX = window.innerWidth - translationPanel.offsetWidth;
                const maxY = window.innerHeight - translationPanel.offsetHeight;
                
                const boundedX = Math.max(0, Math.min(x, maxX));
                const boundedY = Math.max(0, Math.min(y, maxY));
                
                translationPanel.style.left = boundedX + 'px';
                translationPanel.style.top = boundedY + 'px';
                translationPanel.style.bottom = 'auto';
                translationPanel.style.transform = 'none';
            } else if (isResizing && translationPanel) {
                const rect = translationPanel.getBoundingClientRect();
                const newWidth = Math.max(300, e.clientX - rect.left);
                const newHeight = Math.max(200, e.clientY - rect.top);
                
                translationPanel.style.width = newWidth + 'px';
                translationPanel.style.height = newHeight + 'px';
            }
        }

        function stopDragging() {
            if (isDragging) {
                isDragging = false;
                if (translationPanel) {
                    translationPanel.classList.remove('dragging');
                }
            }
            if (isResizing) {
                isResizing = false;
            }
        }

        function toggleMinimize() {
            if (!translationPanel || !minimizeBtn) return;
            
            isMinimized = !isMinimized;
            translationPanel.classList.toggle('minimized', isMinimized);
            
            minimizeBtn.innerHTML = isMinimized ? 
                '<svg viewBox="0 0 24 24"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"/></svg>' :
                '<svg viewBox="0 0 24 24"><path d="M19,13H5V11H19V13Z"/></svg>';
            
            minimizeBtn.title = isMinimized ? 'Restore' : 'Minimize';
        }

        function closePanel() {
            if (translationPanel) {
                translationPanel.style.display = 'none';
            }
        }

        function showPanel() {
            if (isElectron) {
                // åœ¨Electronç¯å¢ƒä¸­åªæ˜¾ç¤ºç‹¬ç«‹ç¿»è¯‘çª—å£ï¼Œä¸æ˜¾ç¤ºä¸»çª—å£é¢æ¿
                showElectronTranslationWindow();
            } else {
                // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­æ˜¾ç¤ºä¸»çª—å£é¢æ¿
                translationPanel.style.display = 'block';
            }
        }

        // Generate unique client ID
        function generateClientId() {
            return 'client_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }
        
        function ensureClientId() {
            if (!clientId) {
                clientId = generateClientId();
                console.log(`Generated new client ID: ${clientId} for this browser tab`);
            }
            return clientId;
        }

        // Update status display
        function updateStatus(text, type = 'ready') {
            if (isElectron) {
                // åœ¨Electronç¯å¢ƒä¸­åªæ›´æ–°ç‹¬ç«‹ç¿»è¯‘çª—å£çš„çŠ¶æ€
                updateElectronStatus(text, type);
            } else {
                // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­æ›´æ–°ä¸»çª—å£é¢æ¿çš„çŠ¶æ€
                if (statusText) {
                    statusText.textContent = text;
                }
                if (statusIndicator) {
                    statusIndicator.className = `status-indicator ${type}`;
                }
                
                // Update panel header title
                if (panelHeader) {
                    const headerTitle = panelHeader.querySelector('h3');
                    if (headerTitle) {
                        if (type === 'processing') {
                            headerTitle.textContent = 'Processing...';
                            if (loadingSpinner) loadingSpinner.classList.remove('hidden');
                        } else if (type === 'error') {
                            headerTitle.textContent = 'Error';
                            if (loadingSpinner) loadingSpinner.classList.add('hidden');
                        } else {
                            headerTitle.textContent = 'Ready to translate';
                            if (loadingSpinner) loadingSpinner.classList.add('hidden');
                        }
                    }
                }
            }
        }

        // Scroll translation to bottom
        function scrollTranslationToBottom() {
            // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸‹æ»šåŠ¨ç¿»è¯‘è¾“å‡º
            if (!isElectron && translationOutput) {
                // ä½¿ç”¨requestAnimationFrameç¡®ä¿DOMæ›´æ–°åå†æ»šåŠ¨
                requestAnimationFrame(() => {
                    // ç°åœ¨ç›´æ¥æ»šåŠ¨translationOutputå…ƒç´ ï¼ˆå®ƒç°åœ¨æœ‰è‡ªå·±çš„æ»šåŠ¨æ¡ï¼‰
                    translationOutput.scrollTop = translationOutput.scrollHeight;
                    
                    // å¦‚æœä»¥ä¸Šä¸å·¥ä½œï¼Œä¹Ÿå°è¯•æ»šåŠ¨translationContentå®¹å™¨
                    const translationContent = document.getElementById('translationContent');
                    if (translationContent) {
                        translationContent.scrollTop = translationContent.scrollHeight;
                    }
                    
                    console.log(`Scrolled to bottom: scrollTop=${translationOutput.scrollTop}, scrollHeight=${translationOutput.scrollHeight}`);
                });
            }
            resetIdleTimer();
        }

        // Create media element (audio or video)
        function createMediaElement(file) {
            // Remove existing media
            const existingMedia = mediaContainer.querySelector('audio, video');
            if (existingMedia) {
                existingMedia.remove();
            }

            // Determine if it's video or audio
            const isVideo = file.type.startsWith('video/');
            const mediaElement = document.createElement(isVideo ? 'video' : 'audio');
            
            mediaElement.controls = true;
            mediaElement.style.width = '100%';
            mediaElement.style.height = '100%';
            mediaElement.src = URL.createObjectURL(file);
            
            // Hide placeholder
            const placeholder = mediaContainer.querySelector('.video-placeholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            mediaContainer.appendChild(mediaElement);
            currentMediaElement = mediaElement;
            
            // Add event listeners
            addMediaEventListeners(mediaElement);
            
            // Show translation panel
            showPanel();
            
            return mediaElement;
        }

        // Add event listeners to media element
        function addMediaEventListeners(mediaElement) {
            mediaElement.addEventListener('play', async () => {
                if (!translationInitialized && sessionId) {
                    try {
                        const currentTime = mediaElement.currentTime;
                        mediaElement.pause();
                        updateStatus('Initializing translation system...', 'processing');
                        
                        await initializeTranslation(mediaElement);
                        mediaElement.currentTime = currentTime;
                        translationPaused = false;
                        
                        if (audioContext && audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        
                        setTimeout(() => {
                            mediaElement.play().then(() => {
                                updateStatus('Playing and translating...', 'processing');
                                resetIdleTimer();
                            }).catch(e => {
                                console.error('Error playing media after initialization:', e);
                                updateStatus('Error playing media: ' + e, 'error');
                            });
                        }, 50);
                        
                        resetIdleTimer();
                    } catch (error) {
                        console.error('Error initializing translation:', error);
                        updateStatus('Error initializing translation: ' + error, 'error');
                    }
                } else if (translationInitialized) {
                    translationPaused = false;
                    updateStatus('Playing and translating...', 'processing');
                    
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume().catch(e => {
                            console.error('Error resuming audio context:', e);
                        });
                    }
                    
                    resetIdleTimer();
                }
            });
            
            mediaElement.addEventListener('pause', () => {
                if (translationInitialized) {
                    translationPaused = true;
                    updateStatus('Translation paused', 'ready');
                    
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().catch(e => {
                            console.error('Error suspending audio context:', e);
                        });
                    }
                }
            });

            mediaElement.addEventListener('ended', () => {
                console.log('Media playback ended, cleaning up...');
                
                // åœ¨Electronç¯å¢ƒä¸­åœæ­¢ä¸“ç”¨éŸ³é¢‘å¤„ç†å™¨
                if (isElectron && electronAudioProcessor) {
                    console.log('ğŸ›‘ Stopping Electron audio processor on media end...');
                    try {
                        electronAudioProcessor.stop();
                        electronAudioProcessor = null;
                        console.log('âœ… Electron audio processor stopped on media end');
                    } catch (error) {
                        console.error('âŒ Error stopping Electron audio processor on media end:', error);
                    }
                } else {
                    // ä¼ ç»Ÿæµè§ˆå™¨å¤„ç†æ–¹å¼
                    if (resampledBuffer.length > 0) {
                        const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                        const finalChunk = new Float32Array(targetChunkSize);
                        finalChunk.set(resampledBuffer);
                        if (ws) ws.send(finalChunk.buffer);
                    }
                    
                    if (processor) processor.disconnect();
                    if (audioContext) audioContext.suspend();
                }
                
                if (ws) ws.close();
                updateStatus('Translation completed', 'ready');
                translationInitialized = false;
            });
        }

        // Initialize translation system
        async function initializeTranslation(mediaElement = currentMediaElement) {
            if (!sessionId || translationInitialized) return;
            
            try {
                // åªåœ¨éElectronç¯å¢ƒä¸‹æ¸…ç©ºç¿»è¯‘è¾“å‡º
                if (!isElectron && translationOutput) {
                    translationOutput.textContent = '';
                }
                translationPaused = false;
                
                const wsUrl = getWebSocketUrl(sessionId);
                console.log(`Connecting to WebSocket at: ${wsUrl}`);
                ws = new WebSocket(wsUrl);
                
                ws.onmessage = (event) => {
                    const message = event.data;
                    console.log(`websocket message: ${message}`);
                    
                    if (typeof message === 'string' && message.startsWith('INITIALIZING:')) {
                        updateStatus(message.substring('INITIALIZING:'.length).trim(), 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('READY:')) {
                        updateStatus('Model is ready. Processing audio...', 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('ERROR:')) {
                        updateStatus(message, 'error');
                        return;
                    }
                    
                    if (!translationPaused) {
                        if (isElectron) {
                            // åœ¨Electronç¯å¢ƒä¸­åªæ›´æ–°ç‹¬ç«‹ç¿»è¯‘çª—å£
                            updateElectronTranslation(message);
                        } else {
                            // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­æ›´æ–°ä¸»çª—å£é¢æ¿
                            translationOutput.textContent = message;
                            // ç¡®ä¿åœ¨å†…å®¹æ›´æ–°åç«‹å³æ»šåŠ¨
                            setTimeout(() => {
                                scrollTranslationToBottom();
                            }, 10); // ç»™DOMä¸€ç‚¹æ—¶é—´æ›´æ–°
                        }
                    }
                };
                
                ws.onerror = (error) => {
                    updateStatus('WebSocket error: ' + error, 'error');
                };
                
                return new Promise((resolve, reject) => {
                    ws.onopen = async () => {
                        try {
                            // åœ¨Electronç¯å¢ƒä¸­ä½¿ç”¨ä¸“ç”¨éŸ³é¢‘å¤„ç†å™¨å¤„ç†åª’ä½“æ–‡ä»¶
                            console.log('ğŸ” Checking Electron conditions:', {
                                isElectron: isElectron,
                                hasElectronAudioProcessor: !!window.ElectronAudioProcessor,
                                hasMediaElement: !!mediaElement,
                                mediaElementType: mediaElement ? mediaElement.tagName : 'null'
                            });
                            
                            // åœ¨Electronç¯å¢ƒä¸­ç­‰å¾…ElectronAudioProcessoråŠ è½½ï¼ˆå¦‚æœéœ€è¦ï¼‰
                            if (isElectron && !window.ElectronAudioProcessor) {
                                console.log('â³ ElectronAudioProcessor not yet loaded, waiting...');
                                await new Promise((resolve) => {
                                    const checkProcessor = () => {
                                        if (window.ElectronAudioProcessor) {
                                            console.log('âœ… ElectronAudioProcessor loaded during wait');
                                            resolve();
                                        } else {
                                            setTimeout(checkProcessor, 50);
                                        }
                                    };
                                    checkProcessor();
                                });
                            }
                            
                            if (isElectron && window.ElectronAudioProcessor && mediaElement) {
                                console.log('ğŸµ Using Electron-specific audio processor for media file...');
                                
                                try {
                                    // ç¡®ä¿æ²¡æœ‰å…¶ä»–éŸ³é¢‘å¤„ç†åœ¨è¿è¡Œ
                                    if (audioContext) {
                                        try {
                                            await audioContext.close();
                                            audioContext = null;
                                            console.log('ğŸ§¹ Closed existing AudioContext for media file processing');
                                        } catch (e) {
                                            console.warn('âš ï¸ Error closing existing AudioContext:', e);
                                        }
                                    }
                                    
                                    // ç¦ç”¨å…¨å±€éŸ³é¢‘å¤„ç†æ ‡å¿—
                                    audioProcessingActive = false;
                                    
                                    electronAudioProcessor = new window.ElectronAudioProcessor();
                                    await electronAudioProcessor.initializeAudio(mediaElement, ws, 'media');
                                    
                                    // è®¾ç½®çŠ¶æ€
                                    translationPaused = false;
                                    translationInitialized = true;
                                    
                                    console.log('ğŸ¯ Media file status set:', {
                                        translationPaused: translationPaused,
                                        translationInitialized: translationInitialized,
                                        electronAudioProcessor: !!electronAudioProcessor,
                                        mediaElement: !!mediaElement
                                    });
                                    
                                    updateStatus('Playing and translating...', 'processing');
                                    resetIdleTimer();
                                    
                                    console.log('âœ… Electron audio processor initialized for media file, skipping traditional processing');
                                    resolve();
                                    return; // é‡è¦ï¼šç›´æ¥è¿”å›ï¼Œä¸æ‰§è¡Œåé¢çš„ScriptProcessorä»£ç 
                                } catch (electronError) {
                                    console.error('âŒ Electron audio processor failed for media file:', electronError);
                                    updateStatus('Electron audio processor failed, using fallback...', 'processing');
                                    
                                    // æ¸…ç†å¤±è´¥çš„Electronå¤„ç†å™¨
                                    if (electronAudioProcessor) {
                                        try {
                                            electronAudioProcessor.stop();
                                            electronAudioProcessor = null;
                                        } catch (cleanupError) {
                                            console.error('Error cleaning up failed Electron processor:', cleanupError);
                                        }
                                    }
                                    
                                    // ç»§ç»­ä½¿ç”¨ä¼ ç»Ÿæµè§ˆå™¨å¤„ç†æ–¹å¼ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
                                    console.log('ğŸ”„ Falling back to traditional browser audio processing for media file...');
                                }
                            }
                            
                            // ä¼ ç»Ÿæµè§ˆå™¨å¤„ç†æ–¹å¼ï¼ˆä»…åœ¨éElectronç¯å¢ƒæˆ–Electronå¤‡é€‰æ–¹æ¡ˆå¤±è´¥æ—¶æ‰§è¡Œï¼‰
                            console.log('Using traditional browser audio processing...');
                            
                            if (audioElementConnected && mediaElement) {
                                console.log('Audio element already connected, recreating it');
                                
                                if (audioContext) {
                                    try {
                                        await audioContext.close();
                                        console.log('Previous AudioContext closed');
                                    } catch (e) {
                                        console.error('Error closing previous AudioContext:', e);
                                    }
                                    audioContext = null;
                                }
                                
                                audioElementConnected = false;
                            }
                            
                            audioContext = new AudioContext();
                            console.log('New AudioContext created with sample rate:', audioContext.sampleRate);
                            
                            if (mediaElement) {
                                audioSource = audioContext.createMediaElementSource(mediaElement);
                                console.log('New MediaElementSource created');
                                audioElementConnected = true;
                            }
                            
                            const originalSampleRate = audioContext.sampleRate;
                            const resampleRatio = targetSampleRate / originalSampleRate;
                            
                            processor = audioContext.createScriptProcessor(segmentSize, 1, 1);
                            
                            processor.onaudioprocess = (e) => {
                                if (ws && ws.readyState === WebSocket.OPEN && !translationPaused) {
                                    const inputData = e.inputBuffer.getChannelData(0);
                                    
                                    const resampledLength = Math.floor(inputData.length * resampleRatio);
                                    const resampledChunk = new Float32Array(resampledLength);
                                    
                                    for (let i = 0; i < resampledLength; i++) {
                                        const originalIndex = Math.floor(i / resampleRatio);
                                        resampledChunk[i] = inputData[originalIndex];
                                    }
                                    
                                    const newBuffer = new Float32Array(resampledBuffer.length + resampledChunk.length);
                                    newBuffer.set(resampledBuffer);
                                    newBuffer.set(resampledChunk, resampledBuffer.length);
                                    resampledBuffer = newBuffer;
                                    
                                    const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                                    
                                    while (resampledBuffer.length >= targetChunkSize) {
                                        const chunk = resampledBuffer.slice(0, targetChunkSize);
                                        ws.send(chunk.buffer);
                                        resampledBuffer = resampledBuffer.slice(targetChunkSize);
                                    }
                                }
                            };
                            
                            if (audioSource) {
                                audioSource.connect(processor);
                                processor.connect(audioContext.destination);
                                audioSource.connect(audioContext.destination);
                            }
                            
                            translationInitialized = true;
                            updateStatus('Playing and translating...', 'processing');
                            resetIdleTimer();
                            
                            resolve();
                        } catch (error) {
                            console.error('Error:', error);
                            updateStatus('Error initializing audio: ' + error, 'error');
                            if (ws) ws.close();
                            translationInitialized = false;
                            reject(error);
                        }
                    };
                });
            } catch (error) {
                updateStatus('Error: ' + error, 'error');
                translationInitialized = false;
                throw error;
            }
        }

        // Clean up audio resources
        function cleanupAudioResources() {
            // åœæ­¢ElectronéŸ³é¢‘å¤„ç†å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (electronAudioProcessor) {
                console.log('ğŸ§¹ Stopping Electron audio processor...');
                try {
                    electronAudioProcessor.stop();
                    electronAudioProcessor = null;
                    console.log('âœ… Electron audio processor stopped');
                } catch (error) {
                    console.error('âŒ Error stopping Electron audio processor:', error);
                }
            }
            
            if (ws) {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                } catch (e) {
                    console.error('Error closing WebSocket:', e);
                }
                ws = null;
            }
            
            if (micStream) {
                micStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Microphone track stopped');
                });
                micStream = null;
            }
            
            if (processor) {
                try {
                    processor.disconnect();
                } catch (e) {
                    console.error('Error disconnecting processor:', e);
                }
                processor = null;
            }
            
            if (audioSource) {
                try {
                    audioSource.disconnect();
                    console.log('Audio source disconnected');
                } catch (e) {
                    console.error('Error disconnecting audio source:', e);
                }
                audioSource = null;
            }
            
            if (audioContext) {
                try {
                    audioContext.close().then(() => {
                        console.log('AudioContext closed successfully');
                        audioContext = null;
                    }).catch(e => {
                        console.error('Error closing audio context:', e);
                    });
                } catch (e) {
                    console.error('Error in audio context cleanup:', e);
                }
            }
            
            resampledBuffer = new Float32Array();
            audioBuffer = new Float32Array();
            firstChunkSent = false;
            
            if (isMicRecording) {
                isMicRecording = false;
                toggleMic.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                    </svg>
                    Record Audio
                `;
                toggleMic.classList.remove('recording');
                micStatus.textContent = '';
                volumeIndicator.classList.add('hidden');
            }
            
            audioElementConnected = false;
        }

        // Session management functions (keeping existing logic)
        function resetIdleTimer() {
            if (idleTimer) {
                clearTimeout(idleTimer);
                console.log('Idle timer reset due to user activity');
            }
            
            if (sessionId) {
                idleTimer = setTimeout(async () => {
                    console.log('ğŸ” Idle timer triggered - checking translation status:', {
                        translationInitialized: translationInitialized,
                        translationPaused: translationPaused,
                        sessionId: sessionId,
                        condition: translationInitialized && !translationPaused
                    });
                    
                    if (translationInitialized && !translationPaused) {
                        console.log('Translation is active, not closing session due to inactivity');
                        resetIdleTimer();
                        return;
                    }
                    
                    console.log('Application idle for 1 minutes, releasing resources...');
                    await cleanupSession();
                    updateStatus('Session closed due to inactivity', 'error');
                }, IDLE_TIMEOUT);
            }
        }

        // handle youtube player
        playBtn.addEventListener("click", async () => {
            if (!youtubeUrl || !youtubeUrl.value || !sessionId) {
                alert("Please enter a YouTube URL and ensure a session is active.");
                updateStatus("Please enter a YouTube URL and ensure a session is active",'error')
                return;
            }

            // Show loading state before requesting backend
            updateStatus("downloading audio first due to Youtube sandbox protection", "processing");

            try {
                const response = await fetch('/download_youtube?' + new URLSearchParams({
                    url: youtubeUrl.value,
                    session_id: sessionId
                }), {
                    method: 'POST'
                });

                //å¤ç”¨ä»£ç 


                const blob = await response.blob();
                const fileType = blob.type;

                if (!fileType.startsWith('video/')) {
                    throw new Error('Expected video file, got: ' + fileType);
                }

                // Reuse upload logic
                const file = new File([blob], 'youtube_video.mp4', { type: fileType });
                createMediaElement(file);
                translationInitialized = false;
                updateStatus('Audio loaded from YouTube. Press play to start translation.', 'ready');
                resetIdleTimer();

                // Show translation panel
                showPanel();
                resetIdleTimer();
            } catch (error) {
                console.error('Error downloading or playing YouTube video:', error);
                updateStatus('Failed to load YouTube video: ' + error, 'error');
            }
        });

        async function cleanupSession() {
            try {
                stopPinging();
                stopQueueCheck();
                
                if (isMicRecording) {
                    stopMicrophone(false);
                } else {
                    volumeLevel.style.width = '0%';
                    volumeIndicator.classList.add('hidden');
                }
                
                micStatus.textContent = '';
                
                if (currentMediaElement) {
                    currentMediaElement.pause();
                    currentMediaElement.currentTime = 0;
                }
                
                cleanupAudioResources();
                
                if (audioContext) {
                    try {
                        if (audioContext.state !== 'closed') {
                            await audioContext.close();
                        }
                        audioContext = null;
                    } catch (e) {
                        console.error('Error closing AudioContext:', e);
                    }
                }
                
                if (sessionId) {
                    console.log(`Deleting session ${sessionId} from client side`);
                    try {
                        const response = await fetch('/delete_session?' + new URLSearchParams({
                            session_id: sessionId
                        }), {
                            method: 'POST'
                        });
                        
                        const data = await response.json();
                        if (!data.success) {
                            console.error('Failed to delete session:', data.error);
                        } else {
                            console.log('Session successfully deleted from server');
                        }
                    } catch (e) {
                        console.error('Error deleting session:', e);
                    }
                    
                    localStorage.removeItem('translationSessionId_' + clientId);
                    sessionId = null;
                    isQueued = false;
                }
                
                // åªåœ¨éElectronç¯å¢ƒä¸‹é‡ç½®ç¿»è¯‘è¾“å‡º
                if (!isElectron && translationOutput) {
                    translationOutput.textContent = 'Translation will appear here...';
                }
                updateLatency.disabled = true;
                resetTranslation.disabled = true;
                
            } catch (error) {
                console.error('Error cleaning up session:', error);
            }
        }

        // Ping and queue management (keeping existing logic)
        function startPinging() {
            if (pingInterval) {
                clearInterval(pingInterval);
            }
            
            if (!sessionId) {
                return;
            }
            
            sendPing();
            pingInterval = setInterval(sendPing, PING_INTERVAL);
            console.log(`Started ping interval (${PING_INTERVAL}ms)`);
        }
        
        function stopPinging() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
                console.log('Stopped ping interval');
            }
        }
        
        async function sendPing() {
            if (!sessionId) {
                stopPinging();
                return;
            }
            
            try {
                const response = await fetch('/ping?' + new URLSearchParams({
                    session_id: sessionId
                }), {
                    method: 'POST',
                    timeout: 10000  // 10ç§’è¶…æ—¶
                });
                
                // æ£€æŸ¥å“åº”çŠ¶æ€
                if (!response.ok) {
                    console.warn(`Ping failed with status ${response.status}: ${response.statusText}`);
                    if (response.status === 503) {
                        console.warn('Service unavailable, will retry next ping');
                    }
                    return;
                }

                // æ£€æŸ¥å“åº”ç±»å‹
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                    console.warn('Ping response is not JSON, got:', contentType);
                    return;
                }
                
                const data = await response.json();
                if (!data.success) {
                    console.warn('Failed to send ping:', data.error);
                    if (data.error === 'Invalid session ID') {
                        stopPinging();
                        sessionId = null;
                        localStorage.removeItem('translationSessionId_' + clientId);
                    }
                }
            } catch (error) {
                // åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
                if (error.name === 'TypeError' && error.message.includes('JSON')) {
                    console.warn('Error parsing ping response as JSON:', error.message);
                } else if (error.name === 'AbortError') {
                    console.warn('Ping request timed out');
                } else {
                    console.error('Error sending ping:', error);
                }
            }
        }

        async function checkQueueStatus(sessionId) {
            if (!sessionId || !isQueued) {
                return;
            }
            
            try {
                const response = await fetch(`/queue_status/${sessionId}`);
                
                // æ£€æŸ¥å“åº”çŠ¶æ€
                if (!response.ok) {
                    console.warn(`Queue status check failed with status ${response.status}: ${response.statusText}`);
                    if (response.status === 503) {
                        console.warn('Service unavailable, will retry queue status check');
                    }
                    return;
                }

                // æ£€æŸ¥å“åº”ç±»å‹
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                    console.warn('Queue status response is not JSON, got:', contentType);
                    return;
                }
                
                const data = await response.json();
                
                if (data.status === 'active') {
                    isQueued = false;
                    if (queueCheckInterval) {
                        clearInterval(queueCheckInterval);
                        queueCheckInterval = null;
                    }
                    
                    updateStatus('Model loaded successfully. Upload audio and press play to start translation.', 'ready');
                    updateElectronStatus('Model loaded successfully. Use video or microphone to start', 'ready');
                    updateLatency.disabled = false;
                    resetTranslation.disabled = false;
                    console.log('Model loaded successfully:', {
                        model: agentType.value,
                        languagePair: languagePair.value,
                        latency: latencyMultiplier.value + 'x'
                    });
                    startPinging();
                    resetIdleTimer();
                } else if (data.status === 'initializing') {
                    updateStatus('Model is initializing, please wait...', 'processing');
                    updateElectronStatus('Loading model...', 'processing');
                } else if (data.status === 'queued') {
                    updateStatus(`Waiting in queue... Position: ${data.queue_position}`, 'processing');
                    updateElectronStatus(`Queue: ${data.queue_position}`, 'processing');
                } else {
                    updateStatus('Error: Session not found in queue or active sessions', 'error');
                    updateElectronStatus('Session error', 'error');
                    isQueued = false;
                    if (queueCheckInterval) {
                        clearInterval(queueCheckInterval);
                        queueCheckInterval = null;
                    }
                }
            } catch (error) {
                // åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
                if (error.name === 'TypeError' && error.message.includes('JSON')) {
                    console.warn('Error parsing queue status response as JSON:', error.message);
                } else {
                    console.error('Error checking queue status:', error);
                    updateStatus('Error checking queue status: ' + error, 'error');
                }
            }
        }
        
        function startQueueCheck(sessionId) {
            if (queueCheckInterval) {
                clearInterval(queueCheckInterval);
            }
            
            checkQueueStatus(sessionId);
            queueCheckInterval = setInterval(() => checkQueueStatus(sessionId), QUEUE_CHECK_INTERVAL);
            console.log(`Started queue status check interval (${QUEUE_CHECK_INTERVAL}ms)`);
        }
        
        function stopQueueCheck() {
            if (queueCheckInterval) {
                clearInterval(queueCheckInterval);
                queueCheckInterval = null;
                console.log('Stopped queue status check interval');
            }
        }

        // Event Listeners
        loadModel.addEventListener('click', async () => {
            try {
                await cleanupSession();
                updateStatus('Loading model...', 'processing');
                
                // åœ¨Electronç¯å¢ƒä¸­ï¼Œç«‹å³æ˜¾ç¤ºç¿»è¯‘çª—å£ä»¥æä¾›åé¦ˆ
                if (isElectron) {
                    showElectronTranslationWindow();
                    // æ›´æ–°ç¿»è¯‘çª—å£çš„çŠ¶æ€
                    updateElectronStatus('Loading model...', 'processing');
                }
                
                currentLatencyMultiplier = parseInt(latencyMultiplier.value);
                const response = await fetch('/init?' + new URLSearchParams({
                    agent_type: agentType.value,
                    language_pair: languagePair.value,
                    latency_multiplier: currentLatencyMultiplier,
                    client_id: clientId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                sessionId = data.session_id;
                localStorage.setItem('translationSessionId_' + clientId, sessionId);
                startPinging();
                
                // Log settings to console
                console.log('Model configuration:', {
                    model: agentType.value,
                    languagePair: languagePair.value,
                    latency: latencyMultiplier.value + 'x',
                    sessionId: sessionId
                });
                
                if (data.queued) {
                    isQueued = true;
                    updateStatus(`Waiting in queue... Position: ${data.queue_position}`, 'processing');
                    updateElectronStatus(`Waiting in queue... Position: ${data.queue_position}`, 'processing');
                    startQueueCheck(sessionId);
                    updateLatency.disabled = true;
                    resetTranslation.disabled = true;
                } else if (data.initializing) {
                    updateStatus('Model is initializing, please wait...', 'processing');
                    updateElectronStatus('Loading model...', 'processing');
                    updateLatency.disabled = true;
                    resetTranslation.disabled = true;
                    isQueued = true;
                    startQueueCheck(sessionId);
                } else {
                    isQueued = false;
                    translationInitialized = false;
                    updateLatency.disabled = false;
                    resetTranslation.disabled = false;
                    updateStatus('Model loaded successfully. Upload audio and press play to start translation.', 'ready');
                    updateElectronStatus('Model loaded. Ready to translate.', 'ready');
                    console.log('Model loaded successfully:', {
                        model: agentType.value,
                        languagePair: languagePair.value,
                        latency: latencyMultiplier.value + 'x'
                    });
                    startPinging();
                    resetIdleTimer();
                }
            } catch (error) {
                updateStatus('Error loading model: ' + error, 'error');
                console.error('Error loading model:', error);
            }
        });

        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                createMediaElement(file);
                translationInitialized = false;
                updateStatus('Audio loaded. Press play to start translation.', 'ready');
                resetIdleTimer();
            }
        });

        // Upload button click handler
        uploadBtn.addEventListener('click', () => {
            audioFile.click();
        });

        // Microphone functionality
        toggleMic.addEventListener('click', async () => {
            if (isMicRecording) {
                stopMicrophone(true);
            } else {
                startMicrophone();
            }
        });

        async function startMicrophone() {
            try {
                if (!sessionId) {
                    micStatus.textContent = 'Please load a model first';
                    console.warn('Microphone access attempted without loaded model');
                    updateStatus('Please load a model first', 'error');
                    return;
                }
                
                console.log('Starting microphone with session ID:', sessionId);
                
                // åœ¨Electronç¯å¢ƒä¸­æ£€æŸ¥éº¦å…‹é£æƒé™
                if (isElectron && window.electronAPI) {
                    console.log('Checking microphone permission in Electron...');
                    try {
                        const permissionStatus = await window.electronAPI.checkMicrophonePermission();
                        console.log('Microphone permission status:', permissionStatus);
                        
                        if (permissionStatus === 'denied') {
                            updateStatus('Microphone permission denied. Please grant permission in System Preferences.', 'error');
                            micStatus.textContent = 'Microphone permission denied. Please check System Preferences.';
                            return;
                        } else if (permissionStatus === 'unknown' || permissionStatus === 'not-determined') {
                            console.log('Requesting microphone permission...');
                            updateStatus('Requesting microphone permission...', 'processing');
                            const granted = await window.electronAPI.requestMicrophonePermission();
                            if (!granted) {
                                updateStatus('Microphone permission denied. Please grant permission and restart the app.', 'error');
                                micStatus.textContent = 'Microphone permission denied.';
                                return;
                            }
                        }
                    } catch (error) {
                        console.error('Error checking microphone permission:', error);
                        // ç»§ç»­æ‰§è¡Œï¼Œå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬çš„Electronæˆ–å…¶ä»–é—®é¢˜
                    }
                }
                
                // Show translation panel
                showPanel();
                
                // ç¡®ä¿åœ¨Electronç¯å¢ƒä¸­ç¿»è¯‘çª—å£å·²æ˜¾ç¤ºå¹¶æ›´æ–°çŠ¶æ€
                if (isElectron) {
                    console.log('Electron environment detected, ensuring translation window is shown');
                    updateStatus('Requesting microphone access...', 'processing');
                }
            
            try {
                console.log('Requesting microphone access...');
                updateStatus('Requesting microphone access...', 'processing');
                
                micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                console.log('Microphone access granted, stream obtained:', micStream);
                updateStatus('Microphone access granted, connecting...', 'processing');
                
                const wsUrl = getWebSocketUrl(sessionId);
                console.log(`Connecting to WebSocket at: ${wsUrl}`);
                
                ws = new WebSocket(wsUrl);
                
                ws.onmessage = (event) => {
                    const message = event.data;
                    console.log('WebSocket message received:', message);

                    // å¤„ç†æ§åˆ¶æ¶ˆæ¯
                    if (typeof message === 'string' && message.startsWith('INITIALIZING:')) {
                        updateStatus(message.substring('INITIALIZING:'.length).trim(), 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('READY:')) {
                        updateStatus('Model is ready. Processing audio...', 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('ERROR:')) {
                        updateStatus(message, 'error');
                        return;
                    }
                    
                    // å¤„ç†ç¿»è¯‘ç»“æœ
                    if (isElectron) {
                        // åœ¨Electronç¯å¢ƒä¸­åªæ›´æ–°ç‹¬ç«‹ç¿»è¯‘çª—å£
                        updateElectronTranslation(message);
                    } else {
                        // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­æ›´æ–°ä¸»çª—å£é¢æ¿
                        translationOutput.textContent = message;
                        // ç¡®ä¿åœ¨å†…å®¹æ›´æ–°åç«‹å³æ»šåŠ¨
                        setTimeout(() => {
                            scrollTranslationToBottom();
                        }, 10); // ç»™DOMä¸€ç‚¹æ—¶é—´æ›´æ–°
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    const errorMsg = 'WebSocket connection error';
                    micStatus.textContent = errorMsg;
                    updateStatus(errorMsg, 'error');
                    stopMicrophone(false);
                };
                
                // ws.onclose = (event) => {
                //     console.log('WebSocket closed:', event.code, event.reason);
                //     if (event.code !== 1000) { // Not a normal closure
                //         const errorMsg = `Connection lost: ${event.code} - ${event.reason || 'Unknown error'}`;
                //         updateStatus(errorMsg, 'error');
                //         console.error('WebSocket connection error:', errorMsg);
                //     } else {
                //         console.log('WebSocket closed normally');
                //     }
                // };
                
                ws.onopen = async () => {
                    console.log('WebSocket connected successfully');
                    
                    try {
                        // åœ¨Electronç¯å¢ƒä¸­ä½¿ç”¨ä¸“ç”¨éŸ³é¢‘å¤„ç†å™¨
                        if (isElectron && window.ElectronAudioProcessor) {
                            console.log('ğŸµ Using Electron-specific audio processor...');
                            
                            try {
                                // ç¡®ä¿æ²¡æœ‰å…¶ä»–éŸ³é¢‘å¤„ç†åœ¨è¿è¡Œ
                                if (audioContext) {
                                    try {
                                        await audioContext.close();
                                        audioContext = null;
                                        console.log('ğŸ§¹ Closed existing AudioContext');
                                    } catch (e) {
                                        console.warn('âš ï¸ Error closing existing AudioContext:', e);
                                    }
                                }
                                
                                // ç¦ç”¨å…¨å±€éŸ³é¢‘å¤„ç†æ ‡å¿—
                                audioProcessingActive = false;
                                
                                electronAudioProcessor = new window.ElectronAudioProcessor();
                                await electronAudioProcessor.initializeAudio(micStream, ws, 'microphone');
                                
                                // è®¾ç½®UIçŠ¶æ€
                                translationPaused = false;
                                translationInitialized = true; // æ·»åŠ è¿™ä¸€è¡Œï¼Œç¡®ä¿idle timeræ£€æŸ¥æ­£ç¡®å·¥ä½œ
                                
                                console.log('ğŸ¯ Microphone status set:', {
                                    translationPaused: translationPaused,
                                    translationInitialized: translationInitialized,
                                    electronAudioProcessor: !!electronAudioProcessor
                                });
                                
                                updateMicrophoneUI(true);
                                updateStatus('Translating from microphone...', 'processing');
                                resetIdleTimer();
                                
                                console.log('âœ… Electron audio processor initialized, skipping traditional processing');
                                return; // ä½¿ç”¨Electronå¤„ç†å™¨ï¼Œå®Œå…¨è·³è¿‡ä¼ ç»Ÿå¤„ç†
                            } catch (electronError) {
                                console.error('âŒ Electron audio processor failed:', electronError);
                                updateStatus('Electron audio processor failed, using fallback...', 'processing');
                                
                                // æ¸…ç†å¤±è´¥çš„Electronå¤„ç†å™¨
                                if (electronAudioProcessor) {
                                    try {
                                        electronAudioProcessor.stop();
                                        electronAudioProcessor = null;
                                    } catch (cleanupError) {
                                        console.error('Error cleaning up failed Electron processor:', cleanupError);
                                    }
                                }
                                
                                // ç»§ç»­ä½¿ç”¨ä¼ ç»Ÿæµè§ˆå™¨å¤„ç†æ–¹å¼ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
                                console.log('ğŸ”„ Falling back to traditional browser audio processing...');
                            }
                        }
                        
                        // ä¼ ç»Ÿæµè§ˆå™¨å¤„ç†æ–¹å¼
                        console.log('Creating AudioContext...');
                        audioContext = new AudioContext();
                        console.log('AudioContext created with sample rate:', audioContext.sampleRate);
                        
                        console.log('Creating MediaStreamSource...');
                        const micSource = audioContext.createMediaStreamSource(micStream);
                        console.log('MediaStreamSource created');
                        
                        console.log('Creating ScriptProcessor...');
                        processor = audioContext.createScriptProcessor(4096, 1, 1);
                        console.log('ScriptProcessor created');
                        
                        const originalSampleRate = audioContext.sampleRate;
                        const resampleRatio = targetSampleRate / originalSampleRate;
                        console.log('Resample ratio:', resampleRatio);
                        
                        processor.onaudioprocess = (e) => {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                const inputData = e.inputBuffer.getChannelData(0);
                                
                                // éŸ³é‡æ£€æµ‹
                                let hasSound = false;
                                let volumeSum = 0;
                                for (let i = 0; i < inputData.length; i++) {
                                    const volume = Math.abs(inputData[i]);
                                    volumeSum += volume;
                                    if (volume > 0.01) {
                                        hasSound = true;
                                    }
                                }
                                
                                const averageVolume = volumeSum / inputData.length;
                                const volumePercent = Math.min(100, Math.round(averageVolume * 1000));
                                volumeLevel.style.width = volumePercent + '%';
                                
                                if (hasSound) {
                                    resetIdleTimer();
                                }
                                
                                // é‡é‡‡æ ·
                                const resampledLength = Math.floor(inputData.length * resampleRatio);
                                const resampledChunk = new Float32Array(resampledLength);
                                
                                for (let i = 0; i < resampledLength; i++) {
                                    const originalIndex = Math.floor(i / resampleRatio);
                                    resampledChunk[i] = inputData[originalIndex];
                                }
                                
                                const newBuffer = new Float32Array(resampledBuffer.length + resampledChunk.length);
                                newBuffer.set(resampledBuffer);
                                newBuffer.set(resampledChunk, resampledBuffer.length);
                                resampledBuffer = newBuffer;
                                
                                const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                                
                                while (resampledBuffer.length >= targetChunkSize) {
                                    const chunk = resampledBuffer.slice(0, targetChunkSize);
                                    try {
                                        if (ws.readyState === WebSocket.OPEN) {
                                            ws.send(chunk.buffer);
                                        }
                                    } catch (error) {
                                        console.error('Error sending audio data:', error);
                                        updateStatus('Error sending audio data: ' + error.message, 'error');
                                        stopMicrophone(false);
                                        return;
                                    }
                                    resampledBuffer = resampledBuffer.slice(targetChunkSize);
                                }
                            }
                        };
                        
                        console.log('Connecting audio nodes...');
                        micSource.connect(processor);
                        processor.connect(audioContext.destination);
                        console.log('Audio nodes connected');
                        
                        translationPaused = false;
                        translationInitialized = true; // ä¿®å¤ï¼šç¡®ä¿ä¼ ç»Ÿæµè§ˆå™¨æ–¹å¼ä¹Ÿæ­£ç¡®è®¾ç½®çŠ¶æ€
                        
                        console.log('ğŸ¯ Traditional browser microphone status set:', {
                            translationPaused: translationPaused,
                            translationInitialized: translationInitialized
                        });
                        
                        toggleMic.innerHTML = `
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                            </svg>
                            Pause Microphone
                        `;
                        toggleMic.classList.add('recording');
                        micStatus.textContent = 'Microphone active. Speaking will be translated in real-time.';
                        volumeIndicator.classList.remove('hidden');
                        isMicRecording = true;
                        updateStatus('Translating from microphone...', 'processing');
                        resetIdleTimer();
                        
                        console.log('Sending initial silent chunk...');
                        const silentChunk = new Float32Array(baseChunkSize * currentLatencyMultiplier);
                        try {
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.send(silentChunk.buffer);
                                console.log('Initial silent chunk sent successfully');
                            }
                        } catch (error) {
                            console.error('Error sending initial silent chunk:', error);
                            updateStatus('Error initializing audio stream: ' + error.message, 'error');
                            stopMicrophone(false);
                        }
                        
                    } catch (audioError) {
                        console.error('Error setting up audio processing:', audioError);
                        updateStatus('Error setting up audio processing: ' + audioError.message, 'error');
                        stopMicrophone(false);
                    }
                };
                
            } catch (error) {
                console.error('Microphone access error:', error);
                let errorMessage = 'Error accessing microphone: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Permission denied. Please allow microphone access and try again.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No microphone found. Please connect a microphone and try again.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += 'Microphone is already in use by another application.';
                } else {
                    errorMessage += error.message;
                }
                
                micStatus.textContent = errorMessage;
                updateStatus(errorMessage, 'error');
                console.error('Full error details:', error);
            }
            } catch (outerError) {
                console.error('Unexpected error in startMicrophone:', outerError);
                updateStatus('Unexpected error starting microphone: ' + outerError.message, 'error');
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°éº¦å…‹é£UIçŠ¶æ€
        function updateMicrophoneUI(isRecording) {
            if (isRecording) {
                toggleMic.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                    </svg>
                    Pause Microphone
                `;
                toggleMic.classList.add('recording');
                micStatus.textContent = 'Microphone active. Speaking will be translated in real-time.';
                volumeIndicator.classList.remove('hidden');
                isMicRecording = true;
            } else {
                toggleMic.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                    </svg>
                    Record Audio
                `;
                toggleMic.classList.remove('recording');
                micStatus.textContent = '';
                volumeIndicator.classList.add('hidden');
                isMicRecording = false;
            }
        }

        function stopMicrophone(isManualPause = false) {
            console.log('ğŸ›‘ Stopping microphone...');
            
            // å¦‚æœä½¿ç”¨ElectronéŸ³é¢‘å¤„ç†å™¨ï¼Œä¼˜å…ˆåœæ­¢å®ƒ
            if (electronAudioProcessor) {
                console.log('ğŸ§¹ Stopping Electron audio processor...');
                try {
                    electronAudioProcessor.stop();
                    electronAudioProcessor = null;
                    console.log('âœ… Electron audio processor stopped');
                } catch (error) {
                    console.error('âŒ Error stopping Electron audio processor:', error);
                }
            }
            
            // ç«‹å³åœæ­¢éŸ³é¢‘å¤„ç†
            if (typeof audioProcessingActive !== 'undefined') {
                audioProcessingActive = false;
                console.log('ğŸš« Audio processing disabled');
            }
            
            if (ws && ws.readyState === WebSocket.OPEN && resampledBuffer.length > 0) {
                const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                const finalChunk = new Float32Array(targetChunkSize);
                finalChunk.set(resampledBuffer);
                try {
                    ws.send(finalChunk.buffer);
                } catch (error) {
                    console.error('Error sending final audio chunk:', error);
                }
            }
            
            if (ws) {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                } catch (e) {
                    console.error('Error closing WebSocket:', e);
                }
                ws = null;
            }
            
            if (micStream) {
                micStream.getTracks().forEach(track => {
                    track.stop();
                });
                micStream = null;
            }
            
            if (processor) {
                try {
                    processor.disconnect();
                } catch (e) {
                    console.error('Error disconnecting processor:', e);
                }
                processor = null;
            }
            
            if (audioContext) {
                try {
                    if (audioContext.state !== 'closed') {
                        audioContext.close().catch(e => {
                            console.error('Error closing audio context:', e);
                        });
                    }
                } catch (e) {
                    console.error('Error in audio context cleanup:', e);
                }
                audioContext = null;
            }
            
            resampledBuffer = new Float32Array();
            volumeLevel.style.width = '0%';
            volumeIndicator.classList.add('hidden');
            
            // æ›´æ–°UIçŠ¶æ€
            updateMicrophoneUI(false);
            
            if (isManualPause) {
                micStatus.textContent = 'Microphone paused.';
            } else {
                micStatus.textContent = '';
            }
            translationPaused = true;
            translationInitialized = false;
        }

        // Reset translation
        resetTranslation.addEventListener('click', async () => {
            if (!sessionId) return;
            
            try {
                if (isMicRecording) {
                    stopMicrophone(false);
                } else {
                    volumeLevel.style.width = '0%';
                    volumeIndicator.classList.add('hidden');
                    micStatus.textContent = '';
                }
                
                cleanupAudioResources();
                
                if (audioContext) {
                    try {
                        if (audioContext.state !== 'closed') {
                            await audioContext.close();
                        }
                        audioContext = null;
                    } catch (e) {
                        console.error('Error closing AudioContext:', e);
                    }
                }
                
                audioElementConnected = false;
                
                // Reset media container
                const existingMedia = mediaContainer.querySelector('audio, video');
                if (existingMedia) {
                    existingMedia.remove();
                }
                
                const placeholder = mediaContainer.querySelector('.video-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                
                currentMediaElement = null;
                
                if (audioFile) {
                    audioFile.value = '';
                }
                
                if (youtubeUrl) {
                    youtubeUrl.value = '';
                }
                
                volumeLevel.style.width = '0%';
                volumeIndicator.classList.add('hidden');
                translationInitialized = false;
                
                const response = await fetch('/reset_translation?' + new URLSearchParams({
                    session_id: sessionId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    if (!isElectron) {
                        // åªåœ¨éElectronç¯å¢ƒä¸‹æ›´æ–°ä¸»çª—å£é¢æ¿
                        translationOutput.textContent = 'Translation will appear here...';
                    }
                    updateStatus(data.message || 'Translation reset successfully. Please select an audio source.', 'ready');
                    updateLatency.disabled = false;
                    console.log('Translation reset successfully');
                } else {
                    updateStatus('Failed to reset translation: ' + data.error, 'error');
                    console.error('Failed to reset translation:', data.error);
                }
            } catch (error) {
                updateStatus('Error resetting translation: ' + error, 'error');
                console.error('Error resetting translation:', error);
            }
        });

        // Update latency
        updateLatency.addEventListener('click', async () => {
            if (!sessionId) return;
            
            try {
                currentLatencyMultiplier = parseInt(latencyMultiplier.value);
                const response = await fetch('/update_latency?' + new URLSearchParams({
                    session_id: sessionId,
                    latency_multiplier: currentLatencyMultiplier
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    updateStatus('Latency updated successfully', 'ready');
                    console.log('Latency updated to:', latencyMultiplier.value + 'x');
                } else {
                    updateStatus('Failed to update latency: ' + data.error, 'error');
                    console.error('Failed to update latency:', data.error);
                }
            } catch (error) {
                updateStatus('Error updating latency: ' + error, 'error');
                console.error('Error updating latency:', error);
            }
        });

        // ä¾›Electronè°ƒç”¨çš„é‡ç½®ç¿»è¯‘å‡½æ•°
        window.resetTranslationFromElectron = async function() {
            if (!sessionId) return;
            
            try {
                if (isMicRecording) {
                    stopMicrophone(false);
                } else {
                    volumeLevel.style.width = '0%';
                    volumeIndicator.classList.add('hidden');
                    micStatus.textContent = '';
                }
                
                cleanupAudioResources();
                
                if (audioContext) {
                    try {
                        if (audioContext.state !== 'closed') {
                            await audioContext.close();
                        }
                        audioContext = null;
                    } catch (e) {
                        console.error('Error closing AudioContext:', e);
                    }
                }
                
                audioElementConnected = false;
                
                // Reset media container
                const existingMedia = mediaContainer.querySelector('audio, video');
                if (existingMedia) {
                    existingMedia.remove();
                }
                
                const placeholder = mediaContainer.querySelector('.video-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                
                currentMediaElement = null;
                
                if (audioFile) {
                    audioFile.value = '';
                }
                
                if (youtubeUrl) {
                    youtubeUrl.value = '';
                }
                
                volumeLevel.style.width = '0%';
                volumeIndicator.classList.add('hidden');
                translationInitialized = false;
                
                const response = await fetch('/reset_translation?' + new URLSearchParams({
                    session_id: sessionId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    updateStatus(data.message || 'Translation reset successfully. Please select an audio source.', 'ready');
                    updateLatency.disabled = false;
                    console.log('Translation reset successfully from Electron');
                } else {
                    updateStatus('Failed to reset translation: ' + data.error, 'error');
                    console.error('Failed to reset translation:', data.error);
                }
            } catch (error) {
                updateStatus('Error resetting translation: ' + error, 'error');
                console.error('Error resetting translation:', error);
            }
        };

        // å…¨å±€é”™è¯¯å¤„ç†ï¼Œé˜²æ­¢ç™½å±
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', event.error);
            if (isElectron) {
                updateElectronStatus('Error: ' + event.error.message, 'error');
            } else {
                // å°è¯•æ¢å¤UIçŠ¶æ€
                try {
                    updateStatus('Application error occurred: ' + event.error.message, 'error');
                } catch (e) {
                    console.error('Error in error handler:', e);
                }
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            if (isElectron) {
                updateElectronStatus('Error: ' + event.reason, 'error');
            } else {
                try {
                    updateStatus('Promise rejection: ' + event.reason, 'error');
                } catch (e) {
                    console.error('Error in rejection handler:', e);
                }
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // æ£€æµ‹Electronç¯å¢ƒå¹¶æ·»åŠ CSSç±»
                if (isElectron || window.electronAPI || navigator.userAgent.includes('Electron')) {
                    document.body.classList.add('electron-app');
                }
                
                ensureClientId();
                
                // åªåœ¨éElectronç¯å¢ƒä¸‹åˆå§‹åŒ–é¢æ¿æ‹–æ‹½
                if (!isElectron) {
                    initializePanelDragging();
                }
                
                const userEvents = ['mousedown', 'keypress', 'scroll', 'touchstart'];
                userEvents.forEach(eventType => {
                    document.addEventListener(eventType, resetIdleTimer);
                });
                
                resetIdleTimer();
                
                const storedSessionId = localStorage.getItem('translationSessionId_' + clientId);
                if (storedSessionId) {
                    checkSessionStatus(storedSessionId);
                }
                
                const pendingDeleteSessions = JSON.parse(localStorage.getItem('pendingDeleteSessions_' + clientId) || '{}');
                if (Object.keys(pendingDeleteSessions).length > 0) {
                    console.log(`Found ${Object.keys(pendingDeleteSessions).length} orphaned sessions to delete`);
                    // Add session cleanup logic here if needed
                }
            } catch (error) {
                console.error('Error during initialization:', error);
                if (isElectron) {
                    updateElectronStatus('Init error: ' + error.message, 'error');
                }
            }
        });

        async function checkSessionStatus(checkSessionId) {
            try {
                const response = await fetch('/delete_session?' + new URLSearchParams({
                    session_id: checkSessionId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    console.log('Session exists and was deleted:', checkSessionId);
                    localStorage.removeItem('translationSessionId_' + clientId);
                } else if (data.error && data.error.includes('Invalid session ID')) {
                    console.log('Stored session no longer exists:', checkSessionId);
                    localStorage.removeItem('translationSessionId_' + clientId);
                } else {
                    console.error('Unexpected error checking session:', data.error);
                    localStorage.removeItem('translationSessionId_' + clientId);
                }
            } catch (error) {
                console.error('Error checking session status:', error);
                localStorage.removeItem('translationSessionId_' + clientId);
            }
        }

        // Toasté€šçŸ¥ç³»ç»Ÿå·²ç§»é™¤
        
        // æ›´æ–°ElectronçŠ¶æ€æ 
        function updateElectronStatusBar(text, type = 'ready') {
            const statusBar = document.getElementById('electronStatusBar');
            const statusIcon = document.getElementById('electronStatusIcon');
            const statusText = document.getElementById('electronStatusText');
            
            if (statusBar && statusIcon && statusText) {
                // æ›´æ–°çŠ¶æ€æ æ ·å¼
                statusBar.className = `electron-status-bar ${type}`;
                statusIcon.className = `electron-status-icon ${type}`;
                statusText.textContent = text;
            }
        }
    </script>
</body>
</html> 