<!DOCTYPE html>
<html>
<head>
    <title>InfiniSST Translation Demo</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-top: 40px;
            margin-bottom: 40px;
            -webkit-app-region: drag; /* ‰ΩøheaderÂèØÊãñÊãΩ */
            cursor: move;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            -webkit-app-region: no-drag; /* Ê†áÈ¢òÊñáÂ≠ó‰∏çÂèØÊãñÊãΩÔºåÈÅøÂÖçÈÄâÊã©ÂÜ≤Á™Å */
        }

        .header p {
            font-size: 1.1rem;
            color: #a0a0a0;
            font-weight: 300;
            -webkit-app-region: no-drag; /* ÂâØÊ†áÈ¢ò‰∏çÂèØÊãñÊãΩ */
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            -webkit-app-region: no-drag; /* ‰∏ªÈù¢ÊùøÂÜÖÂÆπ‰∏çÂèØÊãñÊãΩ */
        }

        .controls-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 2fr;
            gap: 20px;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group.buttons-group {
            /* JavaScript‰ºöÂú®Electron‰∏≠Âä®ÊÄÅË∞ÉÊï¥‰ΩçÁΩÆ */
        }

        .button-row {
            display: flex;
            gap: 12px;
            align-items: stretch;
        }

        .button-row .btn {
            flex: 1;
            min-width: 120px;
        }

        .control-group label {
            font-size: 0.9rem;
            color: #a0a0a0;
            font-weight: 500;
        }

        .control-group select, .control-group input {
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            padding: 0 12px;
            font-size: 0.9rem;
        }

        .control-group select:focus, .control-group input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .btn {
            height: 48px;
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 12px 16px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: rgba(255, 255, 255, 0.1) !important;
            color: rgba(255, 255, 255, 0.5) !important;
            cursor: not-allowed;
            transform: none;
        }

        /* Âº∫Âà∂Á°Æ‰øùÊåâÈíÆÊ†∑ÂºèÂ∫îÁî® */
        .buttons-group .btn {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%) !important;
            color: white !important;
            border: none !important;
        }

        .buttons-group .btn:disabled {
            background: linear-gradient(45deg, rgba(79, 172, 254, 0.5) 0%, rgba(0, 242, 254, 0.4) 100%) !important;
            color: rgba(255, 255, 255, 0.8) !important;
        }

        .input-section {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 16px;
        }

        .input-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .input-item.youtube-section {
            flex-direction: row;
            gap: 15px;
            align-items: center;
        }

        .upload-btn, .record-btn {
            padding: 16px 24px;
            border: none;
            border-radius: 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 56px;
            white-space: nowrap;
            width: 100%;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .record-btn {
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .record-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 87, 108, 0.4);
        }

        .record-btn.recording {
            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
            animation: pulse 2s infinite;
        }

        .system-audio-btn {
            background: linear-gradient(45deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 16px 24px;
            border: none;
            border-radius: 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 56px;
            white-space: nowrap;
            width: 100%;
        }

        .system-audio-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(106, 17, 203, 0.4);
        }

        .system-audio-btn.capturing {
            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
            animation: pulse 2s infinite;
        }

        .blackhole-btn {
            background: linear-gradient(45deg, #ffa726 0%, #fb8c00 100%);
            color: white;
            padding: 16px 24px;
            border: none;
            border-radius: 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 56px;
            white-space: nowrap;
            width: 100%;
        }

        .blackhole-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 167, 38, 0.4);
        }

        .blackhole-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .blackhole-btn.installing {
            background: linear-gradient(45deg, #4caf50 0%, #2e7d32 100%);
            animation: pulse 2s infinite;
        }

        .blackhole-btn.installed {
            background: linear-gradient(45deg, #4caf50 0%, #388e3c 100%);
            cursor: default;
            transform: none;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .blackhole-btn.installed:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0); }
        }

        .play-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.4);
        }

        .url-input {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            min-height: 56px;
        }

        .url-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2);
        }

        .url-input::placeholder {
            color: #888;
        }

        .video-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-placeholder {
            color: #666;
            font-size: 1.2rem;
            text-align: center;
        }

        audio, video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* ElectronÊ®°Âºè‰∏ãÁöÑÁ¥ßÂáëÂ∏ÉÂ±ÄÊ†∑Âºè */
        .electron-mode .video-section {
            display: none !important;
            height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .electron-mode .container {
            padding-bottom: 5px !important;
        }

        .electron-mode .main-panel {
            margin-bottom: 5px !important;
            padding-bottom: 5px !important;
        }

        .electron-mode .input-section {
            margin-bottom: 5px !important;
            padding-bottom: 0 !important;
        }

        .electron-mode .upload-btn, 
        .electron-mode .record-btn, 
        .electron-mode .system-audio-btn {
            margin-bottom: 0 !important;
        }

        .electron-mode .button-group {
            margin-bottom: 0 !important;
            gap: 10px !important;
        }

        /* Floating Translation Panel */
        .translation-panel {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 60px);
            max-width: 1160px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: all 0.3s ease;
            cursor: move;
            user-select: none;
        }

        .translation-panel.minimized {
            height: 60px;
            overflow: hidden;
        }

        .translation-panel.dragging {
            transition: none;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7);
        }

        .translation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .translation-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .panel-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .status-indicator {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-indicator.ready {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-indicator.processing {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .status-indicator.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .panel-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .panel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .panel-btn svg {
            width: 12px;
            height: 12px;
        }

        .panel-btn.reset-btn {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            width: auto;
            height: auto;
        }

        .panel-btn.reset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
        }

        .panel-btn.reset-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .translation-content {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .translation-output {
            min-height: 120px;
            max-height: 260px; /* Ê∑ªÂä†ÊúÄÂ§ßÈ´òÂ∫¶ÈôêÂà∂ */
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 1rem;
            line-height: 1.5;
            white-space: pre-wrap;
            color: #ffffff;
            overflow-y: auto; /* ÂΩìÂÜÖÂÆπË∂ÖÂá∫Êó∂ÊòæÁ§∫ÊªöÂä®Êù° */
            overflow-x: hidden; /* ÈöêËóèÊ®™ÂêëÊªöÂä®Êù° */
            /* Ëá™ÂÆö‰πâÊªöÂä®Êù°Ê†∑Âºè */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(255, 255, 255, 0.1);
        }

        /* WebkitÊµèËßàÂô®ÁöÑÊªöÂä®Êù°Ê†∑Âºè */
        .translation-output::-webkit-scrollbar {
            width: 6px;
        }

        .translation-output::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .translation-output::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .translation-output::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .volume-indicator {
            margin-top: 15px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .volume-level {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4caf50 0%, #8bc34a 50%, #ffeb3b 75%, #ff9800 90%, #f44336 100%);
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        .hidden {
            display: none !important;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            cursor: pointer;
        }

        .mic-status {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #a0a0a0;
            text-align: center;
        }

        @media (max-width: 1024px) {
            .input-section {
                grid-template-columns: 1fr;
                gap: 15px;
                text-align: center;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-panel {
                padding: 20px;
            }

            .translation-panel {
                left: 15px;
                right: 15px;
                bottom: 15px;
                width: auto;
                max-width: none;
                transform: none;
            }
        }

        /* Icon styles */
        .icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4facfe;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Resize handle */
        .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nw-resize;
            background: linear-gradient(-45deg, transparent 0%, transparent 40%, rgba(255,255,255,0.1) 40%, rgba(255,255,255,0.1) 60%, transparent 60%);
        }

        /* ToastÈÄöÁü•Á≥ªÁªüÂ∑≤ÁßªÈô§ */

        /* Áä∂ÊÄÅÊ†èÂú®ElectronÁéØÂ¢É‰∏≠ÁöÑÊ†∑ÂºèË∞ÉÊï¥ */
        .electron-status-bar {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .electron-status-bar.ready {
            border-left: 4px solid #4caf50;
        }

        .electron-status-bar.processing {
            border-left: 4px solid #ff9800;
        }

        .electron-status-bar.error {
            border-left: 4px solid #f44336;
        }

        .electron-status-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .electron-status-icon.ready {
            background: #4caf50;
        }

        .electron-status-icon.processing {
            background: #ff9800;
            animation: pulse 2s infinite;
        }

        .electron-status-icon.error {
            background: #f44336;
        }
    </style>
</head>
<body>
    <!-- Electron‰∏ìÁî®Èü≥È¢ëÂ§ÑÁêÜÂô® -->
    <script src="/static/electron-audio-fix.js"></script>
    
    <!-- ToastÈÄöÁü•ÂÆπÂô®Â∑≤ÁßªÈô§ -->
    
    <div class="container">
        <div class="header">
            <h1>InfiniSST Translation Demo</h1>
            <p>Simultaneous end-to-end speech translation powered by LLM</p>
        </div>

        <div class="main-panel">
            <!-- Model Configuration -->
            <div class="controls-section">
                <div class="control-group">
                    <label>Model</label>
                    <select id="agentType">
                        <option value="InfiniSST">InfiniSST</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Language Pair</label>
                    <select id="languagePair">
                        <option value="English -> Chinese">English ‚Üí Chinese</option>
                        <option value="English -> Italian">English ‚Üí Italian</option>
<!--                        TODO ÊöÇÊó∂Ê≤°ËÆ≠ÁªÉ-->
<!--                        <option value="English -> German">English ‚Üí German</option>-->
<!--                        <option value="English -> Spanish">English ‚Üí Spanish</option>-->
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Latency</label>
                    <select id="latencyMultiplier">
                        <option value="1">1x (Fastest)</option>
                        <option value="2" selected>2x (Default)</option>
                        <option value="3">3x (More Accurate)</option>
                        <option value="4">4x (Most Accurate)</option>
                    </select>
                </div>
                
                <div class="control-group buttons-group">
                    <div class="button-row">
                        <button id="loadModel" class="btn">Load Model</button>
                        <button id="updateLatency" class="btn" disabled>Update Latency</button>
                    </div>
                </div>
            </div>

            <!-- Audio Input Section -->
            <div class="input-section" id="audioInputSection">
                <!-- Web Mode Buttons -->
                <div class="input-item" id="webUploadItem">
                    <button class="upload-btn" type="button" id="uploadBtn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                        </svg>
                        Upload Video/Audio
                    </button>
                    <input type="file" id="audioFile" class="file-input" accept="audio/*,video/*" />
                </div>
                
                <div class="input-item youtube-section" id="webYoutubeItem">
                    <input type="url" id="youtubeUrl" class="url-input" placeholder="https://www.youtube.com/watch?v=..." />
                    <button id="playBtn" class="play-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                        </svg>
                    </button>
                </div>
                
                <!-- Electron Mode System Audio Capture Button -->
                <div class="input-item" id="electronSystemAudioItem" style="display: none;">
                    <button class="system-audio-btn" type="button" id="systemAudioBtn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M3,9V15H7L12,20V4L7,9H3M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>
                        </svg>
                        Capture System Audio
                    </button>
                </div>
                

                
                <div class="input-item">
                    <button id="toggleMic" class="record-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                        </svg>
                        Record Audio
                    </button>
                </div>
            </div>

            <!-- Microphone Status -->
            <div id="micStatus" class="mic-status"></div>
            <div class="volume-indicator hidden" id="volumeIndicator">
                <div id="volumeLevel" class="volume-level"></div>
            </div>

            <!-- Video/Audio Player (hidden in Electron mode) -->
            <div class="video-section" id="videoSection">
                <div class="video-container" id="mediaContainer">
                    <div class="video-placeholder" id="videoPlaceholder">
                        <p>Upload a video/audio file or enter a YouTube URL to begin</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Translation Panel -->
    <div id="translationPanel" class="translation-panel">
        <div class="translation-header" id="panelHeader">
            <div class="header-left">
                <h3>Ready to translate</h3>
                <div id="statusIndicator" class="status-indicator ready">
                    <div class="loading hidden" id="loadingSpinner"></div>
                    <span id="statusText">Ready</span>
                </div>
            </div>
            <div class="panel-controls">
                <button id="resetTranslation" class="panel-btn reset-btn" disabled>Reset</button>
                <button id="minimizeBtn" class="panel-btn" title="Minimize">
                    <svg viewBox="0 0 24 24">
                        <path d="M19,13H5V11H19V13Z"/>
                    </svg>
                </button>
                <button id="closeBtn" class="panel-btn" title="Close">
                    <svg viewBox="0 0 24 24">
                        <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="translation-content" id="translationContent">
            <div id="translationOutput" class="translation-output">
                Translation will appear here...
            </div>
        </div>
        <div class="resize-handle" id="resizeHandle"></div>
    </div>

    <script>
        let ws = null;
        let sessionId = null;
        let audioContext = null;
        let audioSource = null;
        let processor = null;
        const segmentSize = 4096;
        const targetSampleRate = 16000;
        const baseChunkSize = 960 * 16;
        let currentLatencyMultiplier = 2;
        let audioBuffer = new Float32Array();
        let resampledBuffer = new Float32Array();
        let firstChunkSent = false;
        let translationPaused = true;
        
        const PRE_BUFFER_DELAY_MS = 300;
        let idleTimer = null;
        const IDLE_TIMEOUT = 5 * 60 * 1000;
        let pingInterval = null;
        const PING_INTERVAL = 5000;
        let deleteRetryInterval = null;
        const SESSION_DELETE_RETRY_INTERVAL = 10000;
        const QUEUE_CHECK_INTERVAL = 2000;
        let queueCheckInterval = null;
        let isQueued = false;
        let clientId = null;
        
        let translationInitialized = false;
        let micStream = null;
        let micRecorder = null;
        let isMicRecording = false;
        let isSystemAudioCapturing = false;
        let systemAudioStream = null;
        let audioElementConnected = false;
        let currentMediaElement = null;
        let audioProcessingActive = false; // ÂÖ®Â±ÄÈü≥È¢ëÂ§ÑÁêÜÁä∂ÊÄÅÊ†áÂøó

        // Panel dragging variables
        let isDragging = false;
        let isResizing = false;
        let dragOffset = { x: 0, y: 0 };
        let isMinimized = false;

        // UI Elements
        const agentType = document.getElementById('agentType');
        const languagePair = document.getElementById('languagePair');
        const latencyMultiplier = document.getElementById('latencyMultiplier');
        const loadModel = document.getElementById('loadModel');
        const updateLatency = document.getElementById('updateLatency');
        const audioFile = document.getElementById('audioFile');
        const youtubeUrl = document.getElementById('youtubeUrl');
        const playBtn = document.getElementById('playBtn');
        const resetTranslation = document.getElementById('resetTranslation');
        const translationOutput = document.getElementById('translationOutput');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const toggleMic = document.getElementById('toggleMic');
        const micStatus = document.getElementById('micStatus');
        const volumeLevel = document.getElementById('volumeLevel');
        const volumeIndicator = document.getElementById('volumeIndicator');
        const mediaContainer = document.getElementById('mediaContainer');
        const uploadBtn = document.getElementById('uploadBtn');
        const systemAudioBtn = document.getElementById('systemAudioBtn');
        
        // Panel elements
        const translationPanel = document.getElementById('translationPanel');
        const panelHeader = document.getElementById('panelHeader');
        const translationContent = document.getElementById('translationContent');
        const minimizeBtn = document.getElementById('minimizeBtn');
        const closeBtn = document.getElementById('closeBtn');
        const resizeHandle = document.getElementById('resizeHandle');

        // Electron ÈõÜÊàêÊ£ÄÊµãÂíåÂàùÂßãÂåñ
        let isElectron = false;
        let serverConfig = null; // Ê∑ªÂä†ÊúçÂä°Âô®ÈÖçÁΩÆ
        let translationWindowShown = false; // Ë∑üË∏™ÁøªËØëÁ™óÂè£Áä∂ÊÄÅ
        let electronAudioProcessor = null; // Electron‰∏ìÁî®Èü≥È¢ëÂ§ÑÁêÜÂô®

        // Electron‰∏ìÁî®ÊéßÂà∂Èù¢ÊùøÂèòÈáèÂ£∞Êòé
        let electronControlPanel = null;
        let translationStyleSettings = {
            fontSize: 14,
            backgroundOpacity: 95,
            textColor: '#ffffff'
        };

        // Electron‰∏ìÁî®ÊéßÂà∂Èù¢ÊùøÂáΩÊï∞
        function createElectronControlPanel() {
            if (electronControlPanel) return;

            // ÂàõÂª∫ÊéßÂà∂Èù¢Êùø
            electronControlPanel = document.createElement('div');
            electronControlPanel.id = 'electronControlPanel';
            electronControlPanel.innerHTML = `
                <div class="electron-panel-header">
                    <h3>Translation Window Control</h3>
                    <button class="panel-toggle-btn" id="panelToggleBtn">‚àí</button>
                </div>
                <div class="electron-panel-content" id="electronPanelContent">
                    <!-- ElectronÁä∂ÊÄÅÊ†è -->
                    <div class="electron-status-bar ready" id="electronStatusBar">
                        <div class="electron-status-icon ready" id="electronStatusIcon"></div>
                        <div class="electron-status-text" id="electronStatusText">Ready - Load model</div>
                    </div>
                    
                    <div class="control-group">
                        <label>Font Size</label>
                        <div class="font-controls">
                            <button class="control-btn" id="electronFontDecrease">A‚àí</button>
                            <span class="font-size-display" id="electronFontSize">14px</span>
                            <button class="control-btn" id="electronFontIncrease">A+</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Background Opacity</label>
                        <div class="opacity-controls">
                            <input type="range" id="opacitySlider" min="0" max="100" value="95" class="opacity-slider">
                            <span class="opacity-display" id="opacityDisplay">95%</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Text Color</label>
                        <div class="text-color-controls">
                            <button class="color-btn active" id="whiteTextBtn" data-color="#ffffff">White</button>
                            <button class="color-btn" id="blackTextBtn" data-color="#000000">Black</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Window Control</label>
                        <div class="window-controls">
                            <button class="control-btn" id="electronShowWindow">Show Window</button>
                            <button class="control-btn" id="electronHideWindow">Hide Window</button>
                            <button class="control-btn reset-btn" id="electronResetTranslation">Reset Translation</button>
                        </div>
                    </div>
                </div>
            `;

            // Ê∑ªÂä†Ê†∑Âºè
            const style = document.createElement('style');
            style.textContent = `
                #electronControlPanel {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    width: 280px;
                    background: rgba(0, 0, 0, 0.9);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 16px;
                    padding: 0;
                    z-index: 2000;
                    backdrop-filter: blur(20px);
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                    transition: all 0.3s ease;
                    -webkit-app-region: no-drag; /* ÊéßÂà∂Èù¢Êùø‰∏çÂèØÊãñÊãΩ */
                }

                .electron-panel-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 16px 20px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 16px 16px 0 0;
                }

                .electron-panel-header h3 {
                    color: #ffffff;
                    font-size: 1rem;
                    font-weight: 600;
                    margin: 0;
                }

                .panel-toggle-btn {
                    width: 24px;
                    height: 24px;
                    border: none;
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 6px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s ease;
                }

                .panel-toggle-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                }

                .electron-panel-content {
                    padding: 20px;
                    transition: all 0.3s ease;
                    overflow: hidden;
                }

                #electronControlPanel.collapsed .electron-panel-content {
                    max-height: 0;
                    padding: 0 20px;
                }

                .control-group {
                    margin-bottom: 20px;
                }

                .control-group:last-child {
                    margin-bottom: 0;
                }

                .control-group label {
                    display: block;
                    color: #a0a0a0;
                    font-size: 0.9rem;
                    font-weight: 500;
                    margin-bottom: 8px;
                }

                .font-controls {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .font-controls .control-btn {
                    width: 32px;
                    height: 28px;
                    border: none;
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.8rem;
                    font-weight: bold;
                    transition: all 0.2s ease;
                }

                .font-controls .control-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                .font-size-display {
                    color: #ffffff;
                    font-size: 0.9rem;
                    font-weight: 600;
                    min-width: 40px;
                    text-align: center;
                }

                .opacity-controls {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    width: 100%;
                    position: relative;
                    z-index: 1;
                }

                .opacity-slider {
                    flex: 1;
                    height: 6px;
                    -webkit-appearance: none;
                    appearance: none;
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 3px;
                    outline: none;
                    border: none;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    min-width: 100px;
                    position: relative;
                    overflow: hidden;
                }

                .opacity-slider::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    height: 100%;
                    background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
                    border-radius: 3px;
                    width: var(--progress, 95%);
                    transition: width 0.1s ease;
                }

                .opacity-slider:hover {
                    background: rgba(255, 255, 255, 0.3);
                }

                .opacity-slider::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 18px;
                    height: 18px;
                    background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
                    border-radius: 50%;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    border: 2px solid rgba(255, 255, 255, 0.8);
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                }

                .opacity-slider::-webkit-slider-thumb:hover {
                    transform: scale(1.15);
                    box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4);
                }

                /* Firefox ÊªëÂùóÊ†∑Âºè */
                .opacity-slider::-moz-range-thumb {
                    width: 18px;
                    height: 18px;
                    background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
                    border-radius: 50%;
                    cursor: pointer;
                    border: 2px solid rgba(255, 255, 255, 0.8);
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                }

                .opacity-slider::-moz-range-track {
                    height: 6px;
                    background: rgba(255, 255, 255, 0.3);
                    border-radius: 3px;
                    border: none;
                }

                .opacity-display {
                    color: #ffffff;
                    font-size: 0.85rem;
                    font-weight: 600;
                    min-width: 35px;
                    text-align: center;
                }

                .text-color-controls {
                    display: flex;
                    gap: 8px;
                }

                .color-btn {
                    flex: 1;
                    padding: 8px 12px;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.8rem;
                    font-weight: 600;
                    transition: all 0.2s ease;
                }

                .color-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                .color-btn.active {
                    background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
                    border-color: #4facfe;
                }

                .window-controls {
                    display: flex;
                    gap: 8px;
                    flex-wrap: wrap;
                }

                .window-controls .control-btn {
                    flex: 1;
                    min-width: 70px;
                    padding: 8px 12px;
                    border: none;
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.8rem;
                    font-weight: 600;
                    transition: all 0.2s ease;
                }

                .window-controls .control-btn:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                .window-controls .reset-btn {
                    background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
                    flex: 1;
                    min-width: 90px;
                    font-size: 0.75rem;
                }

                .window-controls .reset-btn:hover {
                    background: linear-gradient(45deg, #369ef7 0%, #00d4fe 100%);
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(electronControlPanel);

            // ÁªëÂÆö‰∫ã‰ª∂
            setupElectronControlEvents();
        }

        function setupElectronControlEvents() {
            // Èù¢ÊùøÊî∂Áº©/Â±ïÂºÄ
            const panelToggleBtn = document.getElementById('panelToggleBtn');
            panelToggleBtn.addEventListener('click', () => {
                electronControlPanel.classList.toggle('collapsed');
                panelToggleBtn.textContent = electronControlPanel.classList.contains('collapsed') ? '+' : '‚àí';
            });

            // Â≠ó‰ΩìÂ§ßÂ∞èÊéßÂà∂
            const fontDecreaseBtn = document.getElementById('electronFontDecrease');
            const fontIncreaseBtn = document.getElementById('electronFontIncrease');
            const fontSizeDisplay = document.getElementById('electronFontSize');

            fontDecreaseBtn.addEventListener('click', () => {
                translationStyleSettings.fontSize = Math.max(10, translationStyleSettings.fontSize - 2);
                updateTranslationStyle();
                fontSizeDisplay.textContent = translationStyleSettings.fontSize + 'px';
            });

            fontIncreaseBtn.addEventListener('click', () => {
                translationStyleSettings.fontSize = Math.min(24, translationStyleSettings.fontSize + 2);
                updateTranslationStyle();
                fontSizeDisplay.textContent = translationStyleSettings.fontSize + 'px';
            });

            // ÈÄèÊòéÂ∫¶ÊéßÂà∂
            const opacitySlider = document.getElementById('opacitySlider');
            const opacityDisplay = document.getElementById('opacityDisplay');

            opacitySlider.addEventListener('input', (e) => {
                translationStyleSettings.backgroundOpacity = parseInt(e.target.value);
                updateTranslationStyle();
                opacityDisplay.textContent = translationStyleSettings.backgroundOpacity + '%';
                // Êõ¥Êñ∞ËøõÂ∫¶Êù°
                e.target.style.setProperty('--progress', translationStyleSettings.backgroundOpacity + '%');
            });

            // ÊñáÂ≠óÈ¢úËâ≤ÊéßÂà∂
            const colorBtns = document.querySelectorAll('.color-btn');
            colorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    colorBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    translationStyleSettings.textColor = btn.dataset.color;
                    updateTranslationStyle();
                });
            });

            // Á™óÂè£ÊéßÂà∂
            const showWindowBtn = document.getElementById('electronShowWindow');
            const hideWindowBtn = document.getElementById('electronHideWindow');
            const resetTranslationBtn = document.getElementById('electronResetTranslation');

            showWindowBtn.addEventListener('click', () => {
                showElectronTranslationWindow();
            });

            hideWindowBtn.addEventListener('click', () => {
                if (window.electronAPI && window.electronAPI.hideTranslationWindow) {
                    window.electronAPI.hideTranslationWindow();
                }
            });

            resetTranslationBtn.addEventListener('click', async () => {
                if (typeof resetTranslationFromElectron === 'function') {
                    await resetTranslationFromElectron();
                }
            });
        }

        function updateTranslationStyle() {
            if (window.electronAPI && window.electronAPI.updateTranslationStyle) {
                window.electronAPI.updateTranslationStyle(translationStyleSettings);
            }
        }

        // Ê£ÄÊµãÊòØÂê¶Âú® Electron ÁéØÂ¢É‰∏≠ËøêË°å
        console.log('üîç Environment detection:', {
            hasWindow: typeof window !== 'undefined',
            hasElectronAPI: typeof window !== 'undefined' && !!window.electronAPI,
            hasElectronAudioProcessor: typeof window !== 'undefined' && !!window.ElectronAudioProcessor
        });
        
        if (typeof window !== 'undefined' && window.electronAPI) {
            isElectron = true;
            console.log('‚úÖ Electron environment confirmed');
            
            // Èò≤Ê≠¢dragEventÂºïÁî®ÈîôËØØ - ‰øÆÂ§çJavaScriptÈîôËØØ
            if (typeof dragEvent === 'undefined') {
                window.dragEvent = null;
                console.log('üîß Defined dragEvent to prevent ReferenceError');
            }
            
            // Âú®ElectronÁéØÂ¢É‰∏≠ÈöêËóè‰∏ªÁ™óÂè£ÁöÑÁøªËØëÈù¢Êùø
            const mainTranslationPanel = document.getElementById('translationPanel');
            if (mainTranslationPanel) {
                mainTranslationPanel.style.display = 'none';
            }
            
            // Á´ãÂç≥Âº∫Âà∂ÂàáÊç¢UIÊòæÁ§∫
            console.log('üîÑ Immediate Electron UI switch...');
            
            // Êõ¥Áõ¥Êé•ÁöÑUIÂàáÊç¢ÊñπÊ≥ïÔºå‰∏ç‰æùËµñÂáΩÊï∞
            try {
                console.log('üöÄ Direct UI switch execution...');
                
                // Á≠âÂæÖDOMÂ∞±Áª™ÂêéÊâßË°å
                setTimeout(() => {
                    const webUpload = document.getElementById('webUploadItem');
                    const webYoutube = document.getElementById('webYoutubeItem');
                    const systemAudio = document.getElementById('electronSystemAudioItem');
                    const videoSec = document.getElementById('videoSection');
                    
                    console.log('üìç Direct UI switch - elements found:', {
                        webUpload: !!webUpload,
                        webYoutube: !!webYoutube,
                        systemAudio: !!systemAudio,
                        videoSec: !!videoSec
                    });
                    
                    if (webUpload) {
                        webUpload.style.display = 'none';
                        webUpload.style.visibility = 'hidden';
                        console.log('üî• HIDDEN webUploadItem DIRECTLY');
                    }
                    
                    if (webYoutube) {
                        webYoutube.style.display = 'none';
                        webYoutube.style.visibility = 'hidden';
                        console.log('üî• HIDDEN webYoutubeItem DIRECTLY');
                    }
                    
                    if (videoSec) {
                        videoSec.style.display = 'none';
                        console.log('üî• HIDDEN videoSection DIRECTLY');
                    }
                    
                    if (systemAudio) {
                        systemAudio.style.display = 'block';
                        systemAudio.style.visibility = 'visible';
                        console.log('üî• SHOWN electronSystemAudioItem DIRECTLY');
                    }
                    
                    console.log('üéØ Direct UI switch completed!');
                }, 100);
                
                // ËÆæÁΩÆÁõëÊéßÔºåÁ°Æ‰øùÁ≥ªÁªüÈü≥È¢ëÊåâÈíÆÂßãÁªàÂèØËßÅ
                setInterval(() => {
                    const systemAudio = document.getElementById('electronSystemAudioItem');
                    
                    // Â¶ÇÊûúÁ≥ªÁªüÈü≥È¢ëÊåâÈíÆË¢´ÈöêËóè‰∫ÜÔºåÈáçÊñ∞ÊòæÁ§∫
                    if (systemAudio && systemAudio.style.display !== 'block') {
                        systemAudio.style.setProperty('display', 'block', 'important');
                        systemAudio.style.setProperty('visibility', 'visible', 'important');
                        console.log('üîÑ Re-enforced electronSystemAudioItem visibility');
                    }
                    
                    // ÁßªÈô§‰ªª‰ΩïÂèØËÉΩÈáçÊñ∞Âá∫Áé∞ÁöÑWebÊ®°ÂºèÂÖÉÁ¥†
                    const webUpload = document.getElementById('webUploadItem');
                    const webYoutube = document.getElementById('webYoutubeItem');
                    
                    if (webUpload) {
                        webUpload.remove();
                        console.log('üîÑ Removed re-appeared webUploadItem');
                    }
                    
                    if (webYoutube) {
                        webYoutube.remove();
                        console.log('üîÑ Removed re-appeared webYoutubeItem');
                    }
                }, 2000); // ÊØè2ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
                
            } catch (directError) {
                console.error('‚ùå Direct UI switch failed:', directError);
                // Â¶ÇÊûúÁõ¥Êé•ÊñπÊ≥ïÂ§±Ë¥•ÔºåÂ∞ùËØïË∞ÉÁî®ÂáΩÊï∞
                try {
                    forceElectronModeUI();
                } catch (funcError) {
                    console.error('‚ùå Function UI switch also failed:', funcError);
                }
            }
            
            // ‰ªéÂΩìÂâçURLËé∑ÂèñÊúçÂä°Âô®ÈÖçÁΩÆ
            const currentUrl = new URL(window.location.href);
            serverConfig = {
                protocol: currentUrl.protocol.replace(':', ''),
                host: currentUrl.hostname,
                port: currentUrl.port || (currentUrl.protocol === 'https:' ? '443' : '80')
            };
            
            console.log('Electron environment detected, server config:', serverConfig);
            
            // Á≠âÂæÖElectronAudioProcessorÂä†ËΩΩÂÆåÊàê
            const checkElectronAudioProcessor = () => {
                if (window.ElectronAudioProcessor) {
                    console.log('‚úÖ ElectronAudioProcessor is now available');
                } else {
                    console.log('‚è≥ Waiting for ElectronAudioProcessor to load...');
                    setTimeout(checkElectronAudioProcessor, 100);
                }
            };
            checkElectronAudioProcessor();
            
            // Á´ãÂç≥ÊòæÁ§∫Áã¨Á´ãÁøªËØëÁ™óÂè£
            setTimeout(() => {
                showElectronTranslationWindow();
                updateElectronStatus('Ready - Load model', 'ready');
            }, 500);
            
            // ÂàõÂª∫Electron‰∏ìÁî®ÊéßÂà∂Èù¢Êùø
            createElectronControlPanel();
            
            // ÊòæÁ§∫ÁâàÊú¨‰ø°ÊÅØ
            const versionInfo = document.getElementById('versionInfo');
            if (versionInfo && window.electronAPI.versions) {
                versionInfo.innerHTML = `
                    Electron: ${window.electronAPI.versions.electron}<br>
                    Node: ${window.electronAPI.versions.node}<br>
                    Chrome: ${window.electronAPI.versions.chrome}
                `;
                versionInfo.classList.remove('hidden');
            }
            
            // ÁõëÂê¨ËèúÂçïÊñá‰ª∂ÊâìÂºÄ‰∫ã‰ª∂
            window.electronAPI.onMenuOpenFile(() => {
                // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©Âô®
                if (audioFile) {
                    audioFile.click();
                }
            });
        }

        // Âº∫Âà∂ÂàáÊç¢Âà∞ElectronÊ®°ÂºèÁöÑUI
        function forceElectronModeUI() {
            console.log('üöÄ FORCE Electron mode UI switch - immediate execution');
            
            // Á´ãÂç≥Êü•ÊâæÂπ∂Êìç‰ΩúÂÖÉÁ¥†
            const webUploadItem = document.getElementById('webUploadItem');
            const webYoutubeItem = document.getElementById('webYoutubeItem');
            const videoSection = document.getElementById('videoSection');
            const electronSystemAudioItem = document.getElementById('electronSystemAudioItem');
            const audioInputSection = document.getElementById('audioInputSection');
            
            console.log('üîç UI Elements found:', {
                webUploadItem: !!webUploadItem,
                webYoutubeItem: !!webYoutubeItem,
                videoSection: !!videoSection,
                electronSystemAudioItem: !!electronSystemAudioItem,
                audioInputSection: !!audioInputSection
            });
            
            // ‰ΩøÁî®ÊúÄÂº∫Âà∂ÁöÑÊñπÊ≥ïÔºöÁõ¥Êé•‰ªéDOMÁßªÈô§WebÊ®°ÂºèÂÖÉÁ¥†
            if (webUploadItem) {
                webUploadItem.remove();
                console.log('üí• REMOVED webUploadItem from DOM');
            } else {
                console.log('‚ÑπÔ∏è webUploadItem already removed or not found');
            }
            
            if (webYoutubeItem) {
                webYoutubeItem.remove();
                console.log('üí• REMOVED webYoutubeItem from DOM');
            } else {
                console.log('‚ÑπÔ∏è webYoutubeItem already removed or not found');
            }
            
            if (videoSection) {
                videoSection.remove();
                console.log('üí• REMOVED videoSection from DOM completely');
            } else {
                console.error('‚ùå videoSection not found!');
            }
            
            // Âº∫Âà∂ÊòæÁ§∫ElectronÊ®°ÂºèÁöÑÁ≥ªÁªüÈü≥È¢ëÊåâÈíÆ
            if (electronSystemAudioItem) {
                electronSystemAudioItem.style.setProperty('display', 'block', 'important');
                electronSystemAudioItem.style.setProperty('visibility', 'visible', 'important');
                electronSystemAudioItem.style.setProperty('opacity', '1', 'important');
                console.log('‚úÖ Shown electronSystemAudioItem with !important');
            } else {
                console.error('‚ùå electronSystemAudioItem not found!');
            }
            
            // Ë∞ÉÊï¥input-sectionÁöÑgridÂ∏ÉÂ±Ä‰∏∫2ÂàóÔºàÁ≥ªÁªüÈü≥È¢ë + ÂΩïÈü≥Ôºâ
            if (audioInputSection) {
                audioInputSection.style.setProperty('grid-template-columns', '1fr 1fr', 'important');
                console.log('‚úÖ Adjusted audioInputSection grid to 2 columns with !important');
            } else {
                console.error('‚ùå audioInputSection not found!');
            }
            
            // videoSection Â∑≤ÁªèÂú®‰∏äÈù¢Ë¢´ÁßªÈô§ÔºåËøôÈáå‰∏çÈúÄË¶ÅÈáçÂ§çÂ§ÑÁêÜ
            console.log('‚ÑπÔ∏è videoSection already removed from DOM above');
            
            // Ë∞ÉÊï¥‰∏ªÈù¢ÊùøÁöÑ‰∏ãËæπË∑ùÔºåÂáèÂ∞ëÁ©∫ÁôΩÁ©∫Èó¥
            const mainPanel = document.querySelector('.main-panel');
            if (mainPanel) {
                mainPanel.style.setProperty('margin-bottom', '10px', 'important');
                mainPanel.style.setProperty('padding-bottom', '10px', 'important');
                console.log('‚úÖ Reduced main panel margin and padding in Electron mode');
            }
            
            // Ëøõ‰∏ÄÊ≠•Áº©Áü≠ÊåâÈíÆÂå∫Âüü‰∏éÂ∫ïÈÉ®ÁöÑË∑ùÁ¶ª
            if (audioInputSection) {
                audioInputSection.style.setProperty('margin-bottom', '10px', 'important');
                audioInputSection.style.setProperty('padding-bottom', '0px', 'important');
                console.log('‚úÖ Reduced audioInputSection margins in Electron mode');
            }
            
            // Áº©Áü≠ÂÆπÂô®‰πãÈó¥ÁöÑÈó¥Ë∑ù
            const container = document.querySelector('.container');
            if (container) {
                container.style.setProperty('padding-bottom', '10px', 'important');
                console.log('‚úÖ Reduced container padding in Electron mode');
            }
            
            // videoSection Â∑≤ÁªèË¢´ÂÆåÂÖ®ÁßªÈô§Ôºå‰∏çÈúÄË¶ÅÂÜçË∞ÉÊï¥Ê†∑Âºè
            console.log('‚ÑπÔ∏è videoSection completely removed, no style adjustments needed');
            
            // Ê∑ªÂä†ElectronÊ®°ÂºèÁöÑCSSÁ±ªÂà∞bodyÂÖÉÁ¥†ÔºåÁî®‰∫éËøõ‰∏ÄÊ≠•Ê†∑ÂºèË∞ÉÊï¥
            document.body.classList.add('electron-mode');
            
            console.log('üéâ FORCE Electron mode UI switch completed');
            
            // Ê∑ªÂä†‰∏Ä‰∏™Âª∂ËøüÂÜçÊ¨°Ê£ÄÊü•ÔºåÁ°Æ‰øùUIÊ≠£Á°ÆÊòæÁ§∫
            setTimeout(() => {
                const remainingWebUpload = document.getElementById('webUploadItem');
                const remainingWebYoutube = document.getElementById('webYoutubeItem');
                const finalSystemAudio = document.getElementById('electronSystemAudioItem');
                const removedVideoSectionElement = document.getElementById('videoSection');
                
                const finalCheck = {
                    webUploadRemoved: !remainingWebUpload,
                    webYoutubeRemoved: !remainingWebYoutube,
                    electronSystemAudioVisible: finalSystemAudio ? finalSystemAudio.style.display === 'block' : false,
                    videoSectionCompletelyRemoved: !removedVideoSectionElement
                };
                console.log('üîç Final UI state check (500ms later):', finalCheck);
            }, 500);
        }

        // ÂàáÊç¢Âà∞ElectronÊ®°ÂºèÁöÑUIÔºàÂÖºÂÆπÊÄßÂáΩÊï∞Ôºâ
        function switchToElectronMode() {
            console.log('üîÑ switchToElectronMode called, delegating to forceElectronModeUI...');
            forceElectronModeUI();
        }

        // ElectronÁøªËØëÁ™óÂè£ËæÖÂä©ÂáΩÊï∞
        function showElectronTranslationWindow() {
            if (isElectron) {
                try {
                    window.electronAPI.showTranslationWindow();
                    translationWindowShown = true;
                    console.log('Electron translation window shown');
                } catch (error) {
                    console.error('Error showing translation window:', error);
                }
            }
        }

        function updateElectronTranslation(text) {
            if (isElectron) {
                // Á°Æ‰øùÁøªËØëÁ™óÂè£Â∑≤ÊòæÁ§∫
                if (!translationWindowShown) {
                    showElectronTranslationWindow();
                }
                // ÂèëÈÄÅÁøªËØëÊõ¥Êñ∞
                try {
                    window.electronAPI.updateTranslation({ text: text });
                    console.log('Translation updated to Electron window:', text.substring(0, 50) + '...');
                } catch (error) {
                    console.error('Error updating Electron translation:', error);
                }
            }
        }

        function updateElectronStatus(text, type = 'ready') {
            if (isElectron) {
                // Êõ¥Êñ∞ElectronÊéßÂà∂Èù¢Êùø‰∏≠ÁöÑÁä∂ÊÄÅÊ†è
                updateElectronStatusBar(text, type);
                
                // ÂèëÈÄÅÂà∞Áã¨Á´ãÁøªËØëÁ™óÂè£Ôºà‰ΩÜÁ™óÂè£‰∏çÂÜçÊòæÁ§∫Áä∂ÊÄÅÔºâ
                try {
                    window.electronAPI.updateTranslationStatus({ text: text, type: type });
                    console.log('Status updated to Electron window:', text, type);
                } catch (error) {
                    console.error('Error updating Electron status:', error);
                }
            }
        }

        // Ëé∑ÂèñWebSocket URLÁöÑËæÖÂä©ÂáΩÊï∞
        function getWebSocketUrl(sessionId) {
            if (isElectron && serverConfig) {
                // Âú®ElectronÁéØÂ¢É‰∏≠Ôºå‰ΩøÁî®ÊúçÂä°Âô®ÈÖçÁΩÆÊûÑÈÄ†WebSocket URL
                const wsProtocol = serverConfig.protocol === 'https' ? 'wss' : 'ws';
                const port = serverConfig.port ? `:${serverConfig.port}` : '';
                return `${wsProtocol}://${serverConfig.host}${port}/wss/${sessionId}`;
            } else {
                // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Ôºå‰ΩøÁî®ÂΩìÂâçÈ°µÈù¢ÁöÑÂçèËÆÆÂíå‰∏ªÊú∫
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                return `${protocol}//${window.location.host}/wss/${sessionId}`;
            }
        }

        // Panel drag functionality
        function initializePanelDragging() {
            // Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®ÔºåÈò≤Ê≠¢Âú®ElectronÁéØÂ¢É‰∏ãÂá∫Èîô
            if (panelHeader) {
                panelHeader.addEventListener('mousedown', startDragging);
            }
            if (resizeHandle) {
                resizeHandle.addEventListener('mousedown', startResizing);
            }
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', stopDragging);

            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', toggleMinimize);
            }
            if (closeBtn) {
                closeBtn.addEventListener('click', closePanel);
            }
        }

        function startDragging(e) {
            if (e.target === minimizeBtn || e.target === closeBtn || e.target.closest('.panel-btn')) {
                return;
            }
            
            if (!translationPanel) return;
            
            isDragging = true;
            translationPanel.classList.add('dragging');
            
            const rect = translationPanel.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            e.preventDefault();
        }

        function startResizing(e) {
            isResizing = true;
            e.preventDefault();
            e.stopPropagation();
        }

        function handleMouseMove(e) {
            if (isDragging && translationPanel) {
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                // Keep panel within viewport bounds
                const maxX = window.innerWidth - translationPanel.offsetWidth;
                const maxY = window.innerHeight - translationPanel.offsetHeight;
                
                const boundedX = Math.max(0, Math.min(x, maxX));
                const boundedY = Math.max(0, Math.min(y, maxY));
                
                translationPanel.style.left = boundedX + 'px';
                translationPanel.style.top = boundedY + 'px';
                translationPanel.style.bottom = 'auto';
                translationPanel.style.transform = 'none';
            } else if (isResizing && translationPanel) {
                const rect = translationPanel.getBoundingClientRect();
                const newWidth = Math.max(300, e.clientX - rect.left);
                const newHeight = Math.max(200, e.clientY - rect.top);
                
                translationPanel.style.width = newWidth + 'px';
                translationPanel.style.height = newHeight + 'px';
            }
        }

        function stopDragging() {
            if (isDragging) {
                isDragging = false;
                if (translationPanel) {
                    translationPanel.classList.remove('dragging');
                }
            }
            if (isResizing) {
                isResizing = false;
            }
        }

        function toggleMinimize() {
            if (!translationPanel || !minimizeBtn) return;
            
            isMinimized = !isMinimized;
            translationPanel.classList.toggle('minimized', isMinimized);
            
            minimizeBtn.innerHTML = isMinimized ? 
                '<svg viewBox="0 0 24 24"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"/></svg>' :
                '<svg viewBox="0 0 24 24"><path d="M19,13H5V11H19V13Z"/></svg>';
            
            minimizeBtn.title = isMinimized ? 'Restore' : 'Minimize';
        }

        function closePanel() {
            if (translationPanel) {
                translationPanel.style.display = 'none';
            }
        }

        function showPanel() {
            if (isElectron) {
                // Âú®ElectronÁéØÂ¢É‰∏≠Âè™ÊòæÁ§∫Áã¨Á´ãÁøªËØëÁ™óÂè£Ôºå‰∏çÊòæÁ§∫‰∏ªÁ™óÂè£Èù¢Êùø
                showElectronTranslationWindow();
            } else {
                // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠ÊòæÁ§∫‰∏ªÁ™óÂè£Èù¢Êùø
                translationPanel.style.display = 'block';
            }
        }

        // Generate unique client ID
        function generateClientId() {
            return 'client_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }
        
        function ensureClientId() {
            if (!clientId) {
                clientId = generateClientId();
                console.log(`Generated new client ID: ${clientId} for this browser tab`);
            }
            return clientId;
        }


        


        // Update status display
        function updateStatus(text, type = 'ready') {
            if (isElectron) {
                // Âú®ElectronÁéØÂ¢É‰∏≠Âè™Êõ¥Êñ∞Áã¨Á´ãÁøªËØëÁ™óÂè£ÁöÑÁä∂ÊÄÅ
                updateElectronStatus(text, type);
            } else {
                // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Êõ¥Êñ∞‰∏ªÁ™óÂè£Èù¢ÊùøÁöÑÁä∂ÊÄÅ
                if (statusText) {
                    statusText.textContent = text;
                }
                if (statusIndicator) {
                    statusIndicator.className = `status-indicator ${type}`;
                }
                
                // Update panel header title
                if (panelHeader) {
                    const headerTitle = panelHeader.querySelector('h3');
                    if (headerTitle) {
                        if (type === 'processing') {
                            headerTitle.textContent = 'Processing...';
                            if (loadingSpinner) loadingSpinner.classList.remove('hidden');
                        } else if (type === 'error') {
                            headerTitle.textContent = 'Error';
                            if (loadingSpinner) loadingSpinner.classList.add('hidden');
                        } else {
                            headerTitle.textContent = 'Ready to translate';
                            if (loadingSpinner) loadingSpinner.classList.add('hidden');
                        }
                    }
                }
            }
        }

        // Scroll translation to bottom
        function scrollTranslationToBottom() {
            // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏ãÊªöÂä®ÁøªËØëËæìÂá∫
            if (!isElectron && translationOutput) {
                // ‰ΩøÁî®requestAnimationFrameÁ°Æ‰øùDOMÊõ¥Êñ∞ÂêéÂÜçÊªöÂä®
                requestAnimationFrame(() => {
                    // Áé∞Âú®Áõ¥Êé•ÊªöÂä®translationOutputÂÖÉÁ¥†ÔºàÂÆÉÁé∞Âú®ÊúâËá™Â∑±ÁöÑÊªöÂä®Êù°Ôºâ
                    translationOutput.scrollTop = translationOutput.scrollHeight;
                    
                    // Â¶ÇÊûú‰ª•‰∏ä‰∏çÂ∑•‰ΩúÔºå‰πüÂ∞ùËØïÊªöÂä®translationContentÂÆπÂô®
                    const translationContent = document.getElementById('translationContent');
                    if (translationContent) {
                        translationContent.scrollTop = translationContent.scrollHeight;
                    }
                    
                    console.log(`Scrolled to bottom: scrollTop=${translationOutput.scrollTop}, scrollHeight=${translationOutput.scrollHeight}`);
                });
            }
            resetIdleTimer();
        }

        // Create media element (audio or video)
        function createMediaElement(file) {
            // Remove existing media
            const existingMedia = mediaContainer.querySelector('audio, video');
            if (existingMedia) {
                existingMedia.remove();
            }

            // Determine if it's video or audio
            const isVideo = file.type.startsWith('video/');
            const mediaElement = document.createElement(isVideo ? 'video' : 'audio');
            
            mediaElement.controls = true;
            mediaElement.style.width = '100%';
            mediaElement.style.height = '100%';
            mediaElement.src = URL.createObjectURL(file);
            
            // Hide placeholder
            const placeholder = mediaContainer.querySelector('.video-placeholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            mediaContainer.appendChild(mediaElement);
            currentMediaElement = mediaElement;
            
            // Add event listeners
            addMediaEventListeners(mediaElement);
            
            // Show translation panel
            showPanel();
            
            return mediaElement;
        }

        // Add event listeners to media element
        function addMediaEventListeners(mediaElement) {
            mediaElement.addEventListener('play', async () => {
                if (!translationInitialized && sessionId) {
                    try {
                        const currentTime = mediaElement.currentTime;
                        mediaElement.pause();
                        updateStatus('Initializing translation system...', 'processing');
                        
                        await initializeTranslation(mediaElement);
                        mediaElement.currentTime = currentTime;
                        translationPaused = false;
                        
                        if (audioContext && audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        
                        setTimeout(() => {
                            mediaElement.play().then(() => {
                                updateStatus('Playing and translating...', 'processing');
                                resetIdleTimer();
                            }).catch(e => {
                                console.error('Error playing media after initialization:', e);
                                updateStatus('Error playing media: ' + e, 'error');
                            });
                        }, 50);
                        
                        resetIdleTimer();
                    } catch (error) {
                        console.error('Error initializing translation:', error);
                        updateStatus('Error initializing translation: ' + error, 'error');
                    }
                } else if (translationInitialized) {
                    translationPaused = false;
                    updateStatus('Playing and translating...', 'processing');
                    
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume().catch(e => {
                            console.error('Error resuming audio context:', e);
                        });
                    }
                    
                    resetIdleTimer();
                }
            });
            
            mediaElement.addEventListener('pause', () => {
                if (translationInitialized) {
                    translationPaused = true;
                    updateStatus('Translation paused', 'ready');
                    
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().catch(e => {
                            console.error('Error suspending audio context:', e);
                        });
                    }
                }
            });

            mediaElement.addEventListener('ended', () => {
                console.log('Media playback ended, cleaning up...');
                
                // Âú®ElectronÁéØÂ¢É‰∏≠ÂÅúÊ≠¢‰∏ìÁî®Èü≥È¢ëÂ§ÑÁêÜÂô®
                if (isElectron && electronAudioProcessor) {
                    console.log('üõë Stopping Electron audio processor on media end...');
                    try {
                        electronAudioProcessor.stop();
                        electronAudioProcessor = null;
                        console.log('‚úÖ Electron audio processor stopped on media end');
                    } catch (error) {
                        console.error('‚ùå Error stopping Electron audio processor on media end:', error);
                    }
                } else {
                    // ‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºè
                    if (resampledBuffer.length > 0) {
                        const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                        const finalChunk = new Float32Array(targetChunkSize);
                        finalChunk.set(resampledBuffer);
                        if (ws) ws.send(finalChunk.buffer);
                    }
                    
                    if (processor) processor.disconnect();
                    if (audioContext) audioContext.suspend();
                }
                
                if (ws) ws.close();
                updateStatus('Translation completed', 'ready');
                translationInitialized = false;
            });
        }

        // Initialize translation system
        async function initializeTranslation(mediaElement = currentMediaElement) {
            if (!sessionId || translationInitialized) return;
            
            try {
                // Âè™Âú®ÈùûElectronÁéØÂ¢É‰∏ãÊ∏ÖÁ©∫ÁøªËØëËæìÂá∫
                if (!isElectron && translationOutput) {
                    translationOutput.textContent = '';
                }
                translationPaused = false;
                
                const wsUrl = getWebSocketUrl(sessionId);
                console.log(`Connecting to WebSocket at: ${wsUrl}`);
                ws = new WebSocket(wsUrl);
                
                ws.onmessage = (event) => {
                    const message = event.data;
                    console.log(`websocket message: ${message}`);
                    
                    if (typeof message === 'string' && message.startsWith('INITIALIZING:')) {
                        updateStatus(message.substring('INITIALIZING:'.length).trim(), 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('READY:')) {
                        updateStatus('Model is ready. Processing audio...', 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('ERROR:')) {
                        updateStatus(message, 'error');
                        return;
                    }
                    
                    if (!translationPaused) {
                        if (isElectron) {
                            // Âú®ElectronÁéØÂ¢É‰∏≠Âè™Êõ¥Êñ∞Áã¨Á´ãÁøªËØëÁ™óÂè£
                            updateElectronTranslation(message);
                        } else {
                            // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Êõ¥Êñ∞‰∏ªÁ™óÂè£Èù¢Êùø
                            translationOutput.textContent = message;
                            // Á°Æ‰øùÂú®ÂÜÖÂÆπÊõ¥Êñ∞ÂêéÁ´ãÂç≥ÊªöÂä®
                            setTimeout(() => {
                                scrollTranslationToBottom();
                            }, 10); // ÁªôDOM‰∏ÄÁÇπÊó∂Èó¥Êõ¥Êñ∞
                        }
                    }
                };
                
                ws.onerror = (error) => {
                    updateStatus('WebSocket error: ' + error, 'error');
                };
                
                return new Promise((resolve, reject) => {
                    ws.onopen = async () => {
                        try {
                            // Âú®ElectronÁéØÂ¢É‰∏≠‰ΩøÁî®‰∏ìÁî®Èü≥È¢ëÂ§ÑÁêÜÂô®Â§ÑÁêÜÂ™í‰ΩìÊñá‰ª∂
                            console.log('üîç Checking Electron conditions:', {
                                isElectron: isElectron,
                                hasElectronAudioProcessor: !!window.ElectronAudioProcessor,
                                hasMediaElement: !!mediaElement,
                                mediaElementType: mediaElement ? mediaElement.tagName : 'null'
                            });
                            
                            // Âú®ElectronÁéØÂ¢É‰∏≠Á≠âÂæÖElectronAudioProcessorÂä†ËΩΩÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
                            if (isElectron && !window.ElectronAudioProcessor) {
                                console.log('‚è≥ ElectronAudioProcessor not yet loaded, waiting...');
                                await new Promise((resolve) => {
                                    const checkProcessor = () => {
                                        if (window.ElectronAudioProcessor) {
                                            console.log('‚úÖ ElectronAudioProcessor loaded during wait');
                                            resolve();
                                        } else {
                                            setTimeout(checkProcessor, 50);
                                        }
                                    };
                                    checkProcessor();
                                });
                            }
                            
                            if (isElectron && window.ElectronAudioProcessor && mediaElement) {
                                console.log('üéµ Using Electron-specific audio processor for media file...');
                                
                                try {
                                    // Á°Æ‰øùÊ≤°ÊúâÂÖ∂‰ªñÈü≥È¢ëÂ§ÑÁêÜÂú®ËøêË°å
                                    if (audioContext) {
                                        try {
                                            await audioContext.close();
                                            audioContext = null;
                                            console.log('üßπ Closed existing AudioContext for media file processing');
                                        } catch (e) {
                                            console.warn('‚ö†Ô∏è Error closing existing AudioContext:', e);
                                        }
                                    }
                                    
                                    // Á¶ÅÁî®ÂÖ®Â±ÄÈü≥È¢ëÂ§ÑÁêÜÊ†áÂøó
                                    audioProcessingActive = false;
                                    
                                    electronAudioProcessor = new window.ElectronAudioProcessor();
                                    await electronAudioProcessor.initializeAudio(mediaElement, ws, 'media');
                                    
                                    // ËÆæÁΩÆÁä∂ÊÄÅ
                                    translationPaused = false;
                                    translationInitialized = true;
                                    
                                    console.log('üéØ Media file status set:', {
                                        translationPaused: translationPaused,
                                        translationInitialized: translationInitialized,
                                        electronAudioProcessor: !!electronAudioProcessor,
                                        mediaElement: !!mediaElement
                                    });
                                    
                                    updateStatus('Playing and translating...', 'processing');
                                    resetIdleTimer();
                                    
                                    console.log('‚úÖ Electron audio processor initialized for media file, skipping traditional processing');
                                    resolve();
                                    return; // ÈáçË¶ÅÔºöÁõ¥Êé•ËøîÂõûÔºå‰∏çÊâßË°åÂêéÈù¢ÁöÑScriptProcessor‰ª£Á†Å
                                } catch (electronError) {
                                    console.error('‚ùå Electron audio processor failed for media file:', electronError);
                                    updateStatus('Electron audio processor failed, using fallback...', 'processing');
                                    
                                    // Ê∏ÖÁêÜÂ§±Ë¥•ÁöÑElectronÂ§ÑÁêÜÂô®
                                    if (electronAudioProcessor) {
                                        try {
                                            electronAudioProcessor.stop();
                                            electronAudioProcessor = null;
                                        } catch (cleanupError) {
                                            console.error('Error cleaning up failed Electron processor:', cleanupError);
                                        }
                                    }
                                    
                                    // ÁªßÁª≠‰ΩøÁî®‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºè‰Ωú‰∏∫Â§áÁî®ÊñπÊ°à
                                    console.log('üîÑ Falling back to traditional browser audio processing for media file...');
                                }
                            }
                            
                            // ‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºèÔºà‰ªÖÂú®ÈùûElectronÁéØÂ¢ÉÊàñElectronÂ§áÈÄâÊñπÊ°àÂ§±Ë¥•Êó∂ÊâßË°åÔºâ
                            console.log('Using traditional browser audio processing...');
                            
                            if (audioElementConnected && mediaElement) {
                                console.log('Audio element already connected, recreating it');
                                
                                if (audioContext) {
                                    try {
                                        await audioContext.close();
                                        console.log('Previous AudioContext closed');
                                    } catch (e) {
                                        console.error('Error closing previous AudioContext:', e);
                                    }
                                    audioContext = null;
                                }
                                
                                audioElementConnected = false;
                            }
                            
                            audioContext = new AudioContext();
                            console.log('New AudioContext created with sample rate:', audioContext.sampleRate);
                            
                            if (mediaElement) {
                                audioSource = audioContext.createMediaElementSource(mediaElement);
                                console.log('New MediaElementSource created');
                                audioElementConnected = true;
                            }
                            
                            const originalSampleRate = audioContext.sampleRate;
                            const resampleRatio = targetSampleRate / originalSampleRate;
                            
                            processor = audioContext.createScriptProcessor(segmentSize, 1, 1);
                            
                            processor.onaudioprocess = (e) => {
                                if (ws && ws.readyState === WebSocket.OPEN && !translationPaused) {
                                    const inputData = e.inputBuffer.getChannelData(0);
                                    
                                    const resampledLength = Math.floor(inputData.length * resampleRatio);
                                    const resampledChunk = new Float32Array(resampledLength);
                                    
                                    for (let i = 0; i < resampledLength; i++) {
                                        const originalIndex = Math.floor(i / resampleRatio);
                                        resampledChunk[i] = inputData[originalIndex];
                                    }
                                    
                                    const newBuffer = new Float32Array(resampledBuffer.length + resampledChunk.length);
                                    newBuffer.set(resampledBuffer);
                                    newBuffer.set(resampledChunk, resampledBuffer.length);
                                    resampledBuffer = newBuffer;
                                    
                                    const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                                    
                                    while (resampledBuffer.length >= targetChunkSize) {
                                        const chunk = resampledBuffer.slice(0, targetChunkSize);
                                        ws.send(chunk.buffer);
                                        resampledBuffer = resampledBuffer.slice(targetChunkSize);
                                    }
                                }
                            };
                            
                            if (audioSource) {
                                audioSource.connect(processor);
                                processor.connect(audioContext.destination);
                                audioSource.connect(audioContext.destination);
                            }
                            
                            translationInitialized = true;
                            updateStatus('Playing and translating...', 'processing');
                            resetIdleTimer();
                            
                            resolve();
                        } catch (error) {
                            console.error('Error:', error);
                            updateStatus('Error initializing audio: ' + error, 'error');
                            if (ws) ws.close();
                            translationInitialized = false;
                            reject(error);
                        }
                    };
                });
            } catch (error) {
                updateStatus('Error: ' + error, 'error');
                translationInitialized = false;
                throw error;
            }
        }

        // Clean up audio resources
        function cleanupAudioResources() {
            // ÂÅúÊ≠¢ElectronÈü≥È¢ëÂ§ÑÁêÜÂô®ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            if (electronAudioProcessor) {
                console.log('üßπ Stopping Electron audio processor...');
                try {
                    electronAudioProcessor.stop();
                    electronAudioProcessor = null;
                    console.log('‚úÖ Electron audio processor stopped');
                } catch (error) {
                    console.error('‚ùå Error stopping Electron audio processor:', error);
                }
            }
            
            if (ws) {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                } catch (e) {
                    console.error('Error closing WebSocket:', e);
                }
                ws = null;
            }
            
            if (micStream) {
                micStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Microphone track stopped');
                });
                micStream = null;
            }
            
            if (processor) {
                try {
                    processor.disconnect();
                } catch (e) {
                    console.error('Error disconnecting processor:', e);
                }
                processor = null;
            }
            
            if (audioSource) {
                try {
                    audioSource.disconnect();
                    console.log('Audio source disconnected');
                } catch (e) {
                    console.error('Error disconnecting audio source:', e);
                }
                audioSource = null;
            }
            
            if (audioContext) {
                try {
                    audioContext.close().then(() => {
                        console.log('AudioContext closed successfully');
                        audioContext = null;
                    }).catch(e => {
                        console.error('Error closing audio context:', e);
                    });
                } catch (e) {
                    console.error('Error in audio context cleanup:', e);
                }
            }
            
            resampledBuffer = new Float32Array();
            audioBuffer = new Float32Array();
            firstChunkSent = false;
            
            if (isMicRecording) {
                isMicRecording = false;
                toggleMic.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                    </svg>
                    Record Audio
                `;
                toggleMic.classList.remove('recording');
                micStatus.textContent = '';
                volumeIndicator.classList.add('hidden');
            }
            
            audioElementConnected = false;
        }

        // Session management functions (keeping existing logic)
        function resetIdleTimer() {
            if (idleTimer) {
                clearTimeout(idleTimer);
                console.log('Idle timer reset due to user activity');
            }
            
            if (sessionId) {
                idleTimer = setTimeout(async () => {
                    console.log('üîç Idle timer triggered - checking translation status:', {
                        translationInitialized: translationInitialized,
                        translationPaused: translationPaused,
                        sessionId: sessionId,
                        condition: translationInitialized && !translationPaused
                    });
                    
                    if (translationInitialized && !translationPaused) {
                        console.log('Translation is active, not closing session due to inactivity');
                        resetIdleTimer();
                        return;
                    }
                    
                    console.log('Application idle for 1 minutes, releasing resources...');
                    await cleanupSession();
                    updateStatus('Session closed due to inactivity', 'error');
                }, IDLE_TIMEOUT);
            }
        }

        // handle youtube player
        playBtn.addEventListener("click", async () => {
            if (!youtubeUrl || !youtubeUrl.value || !sessionId) {
                alert("Please enter a YouTube URL and ensure a session is active.");
                updateStatus("Please enter a YouTube URL and ensure a session is active",'error')
                return;
            }

            // Show loading state before requesting backend
            updateStatus("downloading audio first due to Youtube sandbox protection", "processing");

            try {
                const response = await fetch('/download_youtube?' + new URLSearchParams({
                    url: youtubeUrl.value,
                    session_id: sessionId
                }), {
                    method: 'POST'
                });

                //Â§çÁî®‰ª£Á†Å


                const blob = await response.blob();
                const fileType = blob.type;

                if (!fileType.startsWith('video/')) {
                    throw new Error('Expected video file, got: ' + fileType);
                }

                // Reuse upload logic
                const file = new File([blob], 'youtube_video.mp4', { type: fileType });
                createMediaElement(file);
                translationInitialized = false;
                updateStatus('Audio loaded from YouTube. Press play to start translation.', 'ready');
                resetIdleTimer();

                // Show translation panel
                showPanel();
                resetIdleTimer();
            } catch (error) {
                console.error('Error downloading or playing YouTube video:', error);
                updateStatus('Failed to load YouTube video: ' + error, 'error');
            }
        });

        async function cleanupSession() {
            try {
                stopPinging();
                stopQueueCheck();
                
                if (isMicRecording) {
                    stopMicrophone(false);
                } else {
                    volumeLevel.style.width = '0%';
                    volumeIndicator.classList.add('hidden');
                }
                
                micStatus.textContent = '';
                
                if (currentMediaElement) {
                    currentMediaElement.pause();
                    currentMediaElement.currentTime = 0;
                }
                
                cleanupAudioResources();
                
                if (audioContext) {
                    try {
                        if (audioContext.state !== 'closed') {
                            await audioContext.close();
                        }
                        audioContext = null;
                    } catch (e) {
                        console.error('Error closing AudioContext:', e);
                    }
                }
                
                if (sessionId) {
                    console.log(`Deleting session ${sessionId} from client side`);
                    try {
                        const response = await fetch('/delete_session?' + new URLSearchParams({
                            session_id: sessionId
                        }), {
                            method: 'POST'
                        });
                        
                        const data = await response.json();
                        if (!data.success) {
                            console.error('Failed to delete session:', data.error);
                        } else {
                            console.log('Session successfully deleted from server');
                        }
                    } catch (e) {
                        console.error('Error deleting session:', e);
                    }
                    
                    localStorage.removeItem('translationSessionId_' + clientId);
                    sessionId = null;
                    isQueued = false;
                }
                
                // Âè™Âú®ÈùûElectronÁéØÂ¢É‰∏ãÈáçÁΩÆÁøªËØëËæìÂá∫
                if (!isElectron && translationOutput) {
                    translationOutput.textContent = 'Translation will appear here...';
                }
                updateLatency.disabled = true;
                resetTranslation.disabled = true;
                
            } catch (error) {
                console.error('Error cleaning up session:', error);
            }
        }

        // Ping and queue management (keeping existing logic)
        function startPinging() {
            if (pingInterval) {
                clearInterval(pingInterval);
            }
            
            if (!sessionId) {
                return;
            }
            
            sendPing();
            pingInterval = setInterval(sendPing, PING_INTERVAL);
            console.log(`Started ping interval (${PING_INTERVAL}ms)`);
        }
        
        function stopPinging() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
                console.log('Stopped ping interval');
            }
        }
        
        async function sendPing() {
            if (!sessionId) {
                console.log('No sessionId available, stopping ping');
                stopPinging();
                return;
            }
            
            // È¢ùÂ§ñÈ™åËØÅsessionIdÊ†ºÂºè
            if (typeof sessionId !== 'string' || sessionId.trim() === '') {
                console.warn('Invalid sessionId format, stopping ping:', sessionId);
                stopPinging();
                sessionId = null;
                localStorage.removeItem('translationSessionId_' + clientId);
                return;
            }
            
            try {
                const response = await fetch('/ping?' + new URLSearchParams({
                    session_id: sessionId
                }), {
                    method: 'POST',
                    timeout: 10000  // 10ÁßíË∂ÖÊó∂
                });
                
                // Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅ
                if (!response.ok) {
                    console.warn(`Ping failed with status ${response.status}: ${response.statusText}`);
                    if (response.status === 503) {
                        console.warn('Service unavailable, will retry next ping');
                    }
                    return;
                }

                // Ê£ÄÊü•ÂìçÂ∫îÁ±ªÂûã
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                    console.warn('Ping response is not JSON, got:', contentType);
                    return;
                }
                
                const data = await response.json();
                if (!data.success) {
                    console.warn('Failed to send ping:', data.error, 'for sessionId:', sessionId);
                    if (data.error === 'Invalid session ID') {
                        console.log('Session invalidated by server, cleaning up');
                        stopPinging();
                        sessionId = null;
                        localStorage.removeItem('translationSessionId_' + clientId);
                        // Êõ¥Êñ∞UIÁä∂ÊÄÅ
                        updateStatus('Session expired. Please load a model again.', 'error');
                        if (updateLatency) updateLatency.disabled = true;
                        if (resetTranslation) resetTranslation.disabled = true;
                    }
                } else {
                    // PingÊàêÂäüÔºåÂèØ‰ª•Âú®debugÊ®°Âºè‰∏ãËÆ∞ÂΩï
                    if (window.location.search.includes('debug=true')) {
                        console.log('Ping successful for session:', sessionId);
                    }
                }
            } catch (error) {
                // Âå∫ÂàÜ‰∏çÂêåÁ±ªÂûãÁöÑÈîôËØØ
                if (error.name === 'TypeError' && error.message.includes('JSON')) {
                    console.warn('Error parsing ping response as JSON:', error.message);
                } else if (error.name === 'AbortError') {
                    console.warn('Ping request timed out');
                } else {
                    console.error('Error sending ping:', error);
                }
            }
        }

        async function checkQueueStatus(sessionId) {
            if (!sessionId || !isQueued) {
                return;
            }
            
            try {
                const response = await fetch(`/queue_status/${sessionId}`);
                
                // Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅ
                if (!response.ok) {
                    console.warn(`Queue status check failed with status ${response.status}: ${response.statusText}`);
                    if (response.status === 503) {
                        console.warn('Service unavailable, will retry queue status check');
                    }
                    return;
                }

                // Ê£ÄÊü•ÂìçÂ∫îÁ±ªÂûã
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                    console.warn('Queue status response is not JSON, got:', contentType);
                    return;
                }
                
                const data = await response.json();
                
                if (data.status === 'active') {
                    isQueued = false;
                    if (queueCheckInterval) {
                        clearInterval(queueCheckInterval);
                        queueCheckInterval = null;
                    }
                    
                    updateStatus('Model loaded successfully. Upload audio and press play to start translation.', 'ready');
                    updateElectronStatus('Model loaded successfully. Use video or microphone to start', 'ready');
                    updateLatency.disabled = false;
                    resetTranslation.disabled = false;
                    console.log('Model loaded successfully:', {
                        model: agentType.value,
                        languagePair: languagePair.value,
                        latency: latencyMultiplier.value + 'x'
                    });
                    startPinging();
                    resetIdleTimer();
                } else if (data.status === 'initializing') {
                    updateStatus('Model is initializing, please wait...', 'processing');
                    updateElectronStatus('Loading model...', 'processing');
                } else if (data.status === 'queued') {
                    updateStatus(`Waiting in queue... Position: ${data.queue_position}`, 'processing');
                    updateElectronStatus(`Queue: ${data.queue_position}`, 'processing');
                } else {
                    updateStatus('Error: Session not found in queue or active sessions', 'error');
                    updateElectronStatus('Session error', 'error');
                    isQueued = false;
                    if (queueCheckInterval) {
                        clearInterval(queueCheckInterval);
                        queueCheckInterval = null;
                    }
                }
            } catch (error) {
                // Âå∫ÂàÜ‰∏çÂêåÁ±ªÂûãÁöÑÈîôËØØ
                if (error.name === 'TypeError' && error.message.includes('JSON')) {
                    console.warn('Error parsing queue status response as JSON:', error.message);
                } else {
                    console.error('Error checking queue status:', error);
                    updateStatus('Error checking queue status: ' + error, 'error');
                }
            }
        }
        
        function startQueueCheck(sessionId) {
            if (queueCheckInterval) {
                clearInterval(queueCheckInterval);
            }
            
            checkQueueStatus(sessionId);
            queueCheckInterval = setInterval(() => checkQueueStatus(sessionId), QUEUE_CHECK_INTERVAL);
            console.log(`Started queue status check interval (${QUEUE_CHECK_INTERVAL}ms)`);
        }
        
        function stopQueueCheck() {
            if (queueCheckInterval) {
                clearInterval(queueCheckInterval);
                queueCheckInterval = null;
                console.log('Stopped queue status check interval');
            }
        }

        // Event Listeners
        loadModel.addEventListener('click', async () => {
            try {
                await cleanupSession();
                updateStatus('Loading model...', 'processing');
                
                // Âú®ElectronÁéØÂ¢É‰∏≠ÔºåÁ´ãÂç≥ÊòæÁ§∫ÁøªËØëÁ™óÂè£‰ª•Êèê‰æõÂèçÈ¶à
                if (isElectron) {
                    showElectronTranslationWindow();
                    // Êõ¥Êñ∞ÁøªËØëÁ™óÂè£ÁöÑÁä∂ÊÄÅ
                    updateElectronStatus('Loading model...', 'processing');
                }
                
                currentLatencyMultiplier = parseInt(latencyMultiplier.value);
                const response = await fetch('/init?' + new URLSearchParams({
                    agent_type: agentType.value,
                    language_pair: languagePair.value,
                    latency_multiplier: currentLatencyMultiplier,
                    client_id: clientId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                sessionId = data.session_id;
                localStorage.setItem('translationSessionId_' + clientId, sessionId);
                startPinging();
                
                // Log settings to console
                console.log('Model configuration:', {
                    model: agentType.value,
                    languagePair: languagePair.value,
                    latency: latencyMultiplier.value + 'x',
                    sessionId: sessionId
                });
                
                if (data.queued) {
                    isQueued = true;
                    updateStatus(`Waiting in queue... Position: ${data.queue_position}`, 'processing');
                    updateElectronStatus(`Waiting in queue... Position: ${data.queue_position}`, 'processing');
                    startQueueCheck(sessionId);
                    updateLatency.disabled = true;
                    resetTranslation.disabled = true;
                } else if (data.initializing) {
                    updateStatus('Model is initializing, please wait...', 'processing');
                    updateElectronStatus('Loading model...', 'processing');
                    updateLatency.disabled = true;
                    resetTranslation.disabled = true;
                    isQueued = true;
                    startQueueCheck(sessionId);
                } else {
                    isQueued = false;
                    translationInitialized = false;
                    updateLatency.disabled = false;
                    resetTranslation.disabled = false;
                    updateStatus('Model loaded successfully. Upload audio and press play to start translation.', 'ready');
                    updateElectronStatus('Model loaded. Ready to translate.', 'ready');
                    console.log('Model loaded successfully:', {
                        model: agentType.value,
                        languagePair: languagePair.value,
                        latency: latencyMultiplier.value + 'x'
                    });
                    startPinging();
                    resetIdleTimer();
                }
            } catch (error) {
                updateStatus('Error loading model: ' + error, 'error');
                console.error('Error loading model:', error);
            }
        });

        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                createMediaElement(file);
                translationInitialized = false;
                updateStatus('Audio loaded. Press play to start translation.', 'ready');
                resetIdleTimer();
            }
        });

        // Upload button click handler
        uploadBtn.addEventListener('click', () => {
            audioFile.click();
        });

        // Microphone functionality
        toggleMic.addEventListener('click', async () => {
            if (isMicRecording) {
                stopMicrophone(true);
            } else {
                startMicrophone();
            }
        });

        // System Audio Capture functionality (Electron only)
        if (systemAudioBtn) {
            systemAudioBtn.addEventListener('click', async () => {
                if (isSystemAudioCapturing) {
                    stopSystemAudioCapture(true);
                } else {
                    
                    console.log('üéØ System audio capture requested (sessionId:', sessionId, ')');
                    console.log('Environment check:', {
                        isElectron: isElectron,
                        hasElectronAPI: !!window.electronAPI,
                        hasSystemAudioConfig: !!(window.electronAPI && window.electronAPI.checkSystemAudioConfig)
                    });
                    
                    if (isElectron && window.electronAPI && window.electronAPI.checkSystemAudioConfig) {
                        console.log('üîç Starting complete system audio configuration check...');
                        
                        // È¶ñÂÖàÊµãËØï IPC ËøûÊé•
                        console.log('üß™ Testing IPC connection before audio config check...');
                        try {
                            const testResult = await window.electronAPI.testIPC();
                            console.log('üß™ IPC test successful:', testResult);
                        } catch (error) {
                            console.error('üß™ IPC test failed:', error);
                            updateStatus('IPC connection failed', 'error');
                            return;
                        }
                        
                        try {
                            console.log('üìû Calling window.electronAPI.checkSystemAudioConfig()...');
                            const audioConfig = await window.electronAPI.checkSystemAudioConfig();
                            console.log('‚úÖ checkSystemAudioConfig result:', audioConfig);
                            
                            if (audioConfig.configured) {
                                console.log('‚úÖ System audio properly configured for capture');
                                updateStatus('System audio configured - Please play any audio/video to begin translation', 'ready');
                            } else if (audioConfig.setupAttempted) {
                                console.log('üîß Setup script was attempted');
                                
                                if (audioConfig.setupResult && audioConfig.setupResult.success) {
                                    updateStatus('Setup script started. Please follow the instructions in Terminal, then restart the app to use system audio capture.', 'ready');
                                    return; // ‰∏çÁªßÁª≠Â∞ùËØïÁ≥ªÁªüÈü≥È¢ëÊçïËé∑ÔºåÂõ†‰∏∫ÈúÄË¶ÅÈáçÂêØ
                                } else if (audioConfig.setupResult) {
                                    updateStatus(`Setup script failed: ${audioConfig.setupResult.message}. System audio capture is not available.`, 'error');
                                    return; // ‰∏çÁªßÁª≠Â∞ùËØïÔºåÂõ†‰∏∫Áõ¥Êé•ÊçïËé∑‰∏çÂèØËÉΩ
                                } else {
                                    updateStatus('Setup script had an unknown result. System audio capture is not available.', 'error');
                                    return;
                                }
                            } else if (audioConfig.setupCancelled) {
                                console.log('‚ùå User cancelled setup');
                                updateStatus(`System audio capture requires configuration. Issue: ${audioConfig.reason}. Setup was cancelled.`, 'error');
                                return; // ‰∏çÁªßÁª≠Â∞ùËØïÔºåÂõ†‰∏∫Áõ¥Êé•ÊçïËé∑‰∏çÂèØËÉΩ
                            } else {
                                // ÊòæÁ§∫ÈÖçÁΩÆÈóÆÈ¢ò‰ΩÜÊ≤°ÊúâËøêË°åÂÆâË£ÖËÑöÊú¨ÁöÑÊÉÖÂÜµÔºà‰∏çÂ∫îËØ•ÂèëÁîüÔºâ
                                console.log('‚ùå Configuration issue but no setup attempted:', audioConfig.reason, audioConfig.details);
                                updateStatus(`System audio configuration error: ${audioConfig.reason}. ${audioConfig.details || ''}`, 'error');
                                return; // ‰∏çÁªßÁª≠Â∞ùËØïÔºåÂõ†‰∏∫Áõ¥Êé•ÊçïËé∑‰∏çÂèØËÉΩ
                            }
                        } catch (error) {
                            console.error('‚ùå Error checking system audio configuration:', error);
                            console.error('Error details:', {
                                name: error.name,
                                message: error.message,
                                stack: error.stack
                            });
                            updateStatus('Configuration check failed, trying direct capture...', 'processing');
                        }
                    } else {
                        console.log('‚ùå Not in Electron environment or checkSystemAudioConfig not available');
                        console.log('isElectron:', isElectron);
                        console.log('window.electronAPI:', !!window.electronAPI);
                        if (window.electronAPI) {
                            console.log('electronAPI methods:', Object.keys(window.electronAPI));
                        }
                        updateStatus('System audio capture is only available in Electron app', 'error');
                        return;
                    }
                    
                    // Âè™ÊúâÂú®ÈÖçÁΩÆÊ≠£Á°ÆÁöÑÊÉÖÂÜµ‰∏ãÊâçÂ∞ùËØïÁ≥ªÁªüÈü≥È¢ëÊçïËé∑
                    startSystemAudioCapture();
                }
            });
        }



        async function startMicrophone() {
            try {
                if (!sessionId) {
                    micStatus.textContent = 'Please load a model first';
                    console.warn('Microphone access attempted without loaded model');
                    updateStatus('Please load a model first', 'error');
                    return;
                }
                
                console.log('Starting microphone with session ID:', sessionId);
                
                // Âú®ElectronÁéØÂ¢É‰∏≠Ê£ÄÊü•È∫¶ÂÖãÈ£éÊùÉÈôê
                if (isElectron && window.electronAPI) {
                    console.log('Checking microphone permission in Electron...');
                    try {
                        const permissionStatus = await window.electronAPI.checkMicrophonePermission();
                        console.log('Microphone permission status:', permissionStatus);
                        
                        if (permissionStatus === 'denied') {
                            updateStatus('Microphone permission denied. Please grant permission in System Preferences.', 'error');
                            micStatus.textContent = 'Microphone permission denied. Please check System Preferences.';
                            return;
                        } else if (permissionStatus === 'unknown' || permissionStatus === 'not-determined') {
                            console.log('Requesting microphone permission...');
                            updateStatus('Requesting microphone permission...', 'processing');
                            const granted = await window.electronAPI.requestMicrophonePermission();
                            if (!granted) {
                                updateStatus('Microphone permission denied. Please grant permission and restart the app.', 'error');
                                micStatus.textContent = 'Microphone permission denied.';
                                return;
                            }
                        }
                    } catch (error) {
                        console.error('Error checking microphone permission:', error);
                        // ÁªßÁª≠ÊâßË°åÔºåÂèØËÉΩÊòØÊóßÁâàÊú¨ÁöÑElectronÊàñÂÖ∂‰ªñÈóÆÈ¢ò
                    }
                }
                
                // Show translation panel
                showPanel();
                
                // Á°Æ‰øùÂú®ElectronÁéØÂ¢É‰∏≠ÁøªËØëÁ™óÂè£Â∑≤ÊòæÁ§∫Âπ∂Êõ¥Êñ∞Áä∂ÊÄÅ
                if (isElectron) {
                    console.log('Electron environment detected, ensuring translation window is shown');
                    updateStatus('Requesting microphone access...', 'processing');
                }
            
            try {
                console.log('Requesting microphone access...');
                updateStatus('Requesting microphone access...', 'processing');
                
                micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                console.log('Microphone access granted, stream obtained:', micStream);
                updateStatus('Microphone access granted, connecting...', 'processing');
                
                const wsUrl = getWebSocketUrl(sessionId);
                console.log(`Connecting to WebSocket at: ${wsUrl}`);
                
                ws = new WebSocket(wsUrl);
                
                ws.onmessage = (event) => {
                    const message = event.data;
                    console.log('WebSocket message received:', message);

                    // Â§ÑÁêÜÊéßÂà∂Ê∂àÊÅØ
                    if (typeof message === 'string' && message.startsWith('INITIALIZING:')) {
                        updateStatus(message.substring('INITIALIZING:'.length).trim(), 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('READY:')) {
                        updateStatus('Model is ready. Processing audio...', 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('ERROR:')) {
                        updateStatus(message, 'error');
                        return;
                    }
                    
                    // Â§ÑÁêÜÁøªËØëÁªìÊûú
                    if (isElectron) {
                        // Âú®ElectronÁéØÂ¢É‰∏≠Âè™Êõ¥Êñ∞Áã¨Á´ãÁøªËØëÁ™óÂè£
                        updateElectronTranslation(message);
                    } else {
                        // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Êõ¥Êñ∞‰∏ªÁ™óÂè£Èù¢Êùø
                        translationOutput.textContent = message;
                        // Á°Æ‰øùÂú®ÂÜÖÂÆπÊõ¥Êñ∞ÂêéÁ´ãÂç≥ÊªöÂä®
                        setTimeout(() => {
                            scrollTranslationToBottom();
                        }, 10); // ÁªôDOM‰∏ÄÁÇπÊó∂Èó¥Êõ¥Êñ∞
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    const errorMsg = 'WebSocket connection error';
                    micStatus.textContent = errorMsg;
                    updateStatus(errorMsg, 'error');
                    stopMicrophone(false);
                };
                
                // ws.onclose = (event) => {
                //     console.log('WebSocket closed:', event.code, event.reason);
                //     if (event.code !== 1000) { // Not a normal closure
                //         const errorMsg = `Connection lost: ${event.code} - ${event.reason || 'Unknown error'}`;
                //         updateStatus(errorMsg, 'error');
                //         console.error('WebSocket connection error:', errorMsg);
                //     } else {
                //         console.log('WebSocket closed normally');
                //     }
                // };
                
                ws.onopen = async () => {
                    console.log('WebSocket connected successfully');
                    
                    try {
                        // Âú®ElectronÁéØÂ¢É‰∏≠‰ΩøÁî®‰∏ìÁî®Èü≥È¢ëÂ§ÑÁêÜÂô®
                        if (isElectron && window.ElectronAudioProcessor) {
                            console.log('üéµ Using Electron-specific audio processor...');
                            
                            try {
                                // Á°Æ‰øùÊ≤°ÊúâÂÖ∂‰ªñÈü≥È¢ëÂ§ÑÁêÜÂú®ËøêË°å
                                if (audioContext) {
                                    try {
                                        await audioContext.close();
                                        audioContext = null;
                                        console.log('üßπ Closed existing AudioContext');
                                    } catch (e) {
                                        console.warn('‚ö†Ô∏è Error closing existing AudioContext:', e);
                                    }
                                }
                                
                                // Á¶ÅÁî®ÂÖ®Â±ÄÈü≥È¢ëÂ§ÑÁêÜÊ†áÂøó
                                audioProcessingActive = false;
                                
                                electronAudioProcessor = new window.ElectronAudioProcessor();
                                await electronAudioProcessor.initializeAudio(micStream, ws, 'microphone');
                                
                                // ËÆæÁΩÆUIÁä∂ÊÄÅ
                                translationPaused = false;
                                translationInitialized = true; // Ê∑ªÂä†Ëøô‰∏ÄË°åÔºåÁ°Æ‰øùidle timerÊ£ÄÊü•Ê≠£Á°ÆÂ∑•‰Ωú
                                
                                console.log('üéØ Microphone status set:', {
                                    translationPaused: translationPaused,
                                    translationInitialized: translationInitialized,
                                    electronAudioProcessor: !!electronAudioProcessor
                                });
                                
                                updateMicrophoneUI(true);
                                updateStatus('Microphone ready - Speak to begin translation', 'ready');
                                resetIdleTimer();
                                
                                console.log('‚úÖ Electron audio processor initialized, skipping traditional processing');
                                return; // ‰ΩøÁî®ElectronÂ§ÑÁêÜÂô®ÔºåÂÆåÂÖ®Ë∑≥Ëøá‰º†ÁªüÂ§ÑÁêÜ
                            } catch (electronError) {
                                console.error('‚ùå Electron audio processor failed:', electronError);
                                updateStatus('Electron audio processor failed, using fallback...', 'processing');
                                
                                // Ê∏ÖÁêÜÂ§±Ë¥•ÁöÑElectronÂ§ÑÁêÜÂô®
                                if (electronAudioProcessor) {
                                    try {
                                        electronAudioProcessor.stop();
                                        electronAudioProcessor = null;
                                    } catch (cleanupError) {
                                        console.error('Error cleaning up failed Electron processor:', cleanupError);
                                    }
                                }
                                
                                // ÁªßÁª≠‰ΩøÁî®‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºè‰Ωú‰∏∫Â§áÁî®ÊñπÊ°à
                                console.log('üîÑ Falling back to traditional browser audio processing...');
                            }
                        }
                        
                        // ‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºè
                        console.log('Creating AudioContext...');
                        audioContext = new AudioContext();
                        console.log('AudioContext created with sample rate:', audioContext.sampleRate);
                        
                        console.log('Creating MediaStreamSource...');
                        const micSource = audioContext.createMediaStreamSource(micStream);
                        console.log('MediaStreamSource created');
                        
                        console.log('Creating ScriptProcessor...');
                        processor = audioContext.createScriptProcessor(4096, 1, 1);
                        console.log('ScriptProcessor created');
                        
                        const originalSampleRate = audioContext.sampleRate;
                        const resampleRatio = targetSampleRate / originalSampleRate;
                        console.log('Resample ratio:', resampleRatio);
                        
                        processor.onaudioprocess = (e) => {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                const inputData = e.inputBuffer.getChannelData(0);
                                
                                // Èü≥ÈáèÊ£ÄÊµã
                                let hasSound = false;
                                let volumeSum = 0;
                                for (let i = 0; i < inputData.length; i++) {
                                    const volume = Math.abs(inputData[i]);
                                    volumeSum += volume;
                                    if (volume > 0.01) {
                                        hasSound = true;
                                    }
                                }
                                
                                const averageVolume = volumeSum / inputData.length;
                                const volumePercent = Math.min(100, Math.round(averageVolume * 1000));
                                volumeLevel.style.width = volumePercent + '%';
                                
                                if (hasSound) {
                                    resetIdleTimer();
                                }
                                
                                // ÈáçÈááÊ†∑
                                const resampledLength = Math.floor(inputData.length * resampleRatio);
                                const resampledChunk = new Float32Array(resampledLength);
                                
                                for (let i = 0; i < resampledLength; i++) {
                                    const originalIndex = Math.floor(i / resampleRatio);
                                    resampledChunk[i] = inputData[originalIndex];
                                }
                                
                                const newBuffer = new Float32Array(resampledBuffer.length + resampledChunk.length);
                                newBuffer.set(resampledBuffer);
                                newBuffer.set(resampledChunk, resampledBuffer.length);
                                resampledBuffer = newBuffer;
                                
                                const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                                
                                while (resampledBuffer.length >= targetChunkSize) {
                                    const chunk = resampledBuffer.slice(0, targetChunkSize);
                                    try {
                                        if (ws.readyState === WebSocket.OPEN) {
                                            ws.send(chunk.buffer);
                                        }
                                    } catch (error) {
                                        console.error('Error sending audio data:', error);
                                        updateStatus('Error sending audio data: ' + error.message, 'error');
                                        stopMicrophone(false);
                                        return;
                                    }
                                    resampledBuffer = resampledBuffer.slice(targetChunkSize);
                                }
                            }
                        };
                        
                        console.log('Connecting audio nodes...');
                        micSource.connect(processor);
                        processor.connect(audioContext.destination);
                        console.log('Audio nodes connected');
                        
                        translationPaused = false;
                        translationInitialized = true; // ‰øÆÂ§çÔºöÁ°Æ‰øù‰º†ÁªüÊµèËßàÂô®ÊñπÂºè‰πüÊ≠£Á°ÆËÆæÁΩÆÁä∂ÊÄÅ
                        
                        console.log('üéØ Traditional browser microphone status set:', {
                            translationPaused: translationPaused,
                            translationInitialized: translationInitialized
                        });
                        
                        toggleMic.innerHTML = `
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                            </svg>
                            Pause Microphone
                        `;
                        toggleMic.classList.add('recording');
                        micStatus.textContent = 'Microphone active. Speaking will be translated in real-time.';
                        volumeIndicator.classList.remove('hidden');
                        isMicRecording = true;
                        updateStatus('Translating from microphone...', 'processing');
                        resetIdleTimer();
                        
                        console.log('Sending initial silent chunk...');
                        const silentChunk = new Float32Array(baseChunkSize * currentLatencyMultiplier);
                        try {
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.send(silentChunk.buffer);
                                console.log('Initial silent chunk sent successfully');
                            }
                        } catch (error) {
                            console.error('Error sending initial silent chunk:', error);
                            updateStatus('Error initializing audio stream: ' + error.message, 'error');
                            stopMicrophone(false);
                        }
                        
                    } catch (audioError) {
                        console.error('Error setting up audio processing:', audioError);
                        updateStatus('Error setting up audio processing: ' + audioError.message, 'error');
                        stopMicrophone(false);
                    }
                };
                
            } catch (error) {
                console.error('Microphone access error:', error);
                let errorMessage = 'Error accessing microphone: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Permission denied. Please allow microphone access and try again.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No microphone found. Please connect a microphone and try again.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += 'Microphone is already in use by another application.';
                } else {
                    errorMessage += error.message;
                }
                
                micStatus.textContent = errorMessage;
                updateStatus(errorMessage, 'error');
                console.error('Full error details:', error);
            }
            } catch (outerError) {
                console.error('Unexpected error in startMicrophone:', outerError);
                updateStatus('Unexpected error starting microphone: ' + outerError.message, 'error');
            }
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÊõ¥Êñ∞È∫¶ÂÖãÈ£éUIÁä∂ÊÄÅ
        function updateMicrophoneUI(isRecording) {
            if (isRecording) {
                toggleMic.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                    </svg>
                    Pause Microphone
                `;
                toggleMic.classList.add('recording');
                micStatus.textContent = 'Microphone active. Speaking will be translated in real-time.';
                volumeIndicator.classList.remove('hidden');
                isMicRecording = true;
            } else {
                toggleMic.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                    </svg>
                    Record Audio
                `;
                toggleMic.classList.remove('recording');
                micStatus.textContent = '';
                volumeIndicator.classList.add('hidden');
                isMicRecording = false;
            }
        }

        function stopMicrophone(isManualPause = false) {
            console.log('üõë Stopping microphone...');
            
            // Â¶ÇÊûú‰ΩøÁî®ElectronÈü≥È¢ëÂ§ÑÁêÜÂô®Ôºå‰ºòÂÖàÂÅúÊ≠¢ÂÆÉ
            if (electronAudioProcessor) {
                console.log('üßπ Stopping Electron audio processor...');
                try {
                    electronAudioProcessor.stop();
                    electronAudioProcessor = null;
                    console.log('‚úÖ Electron audio processor stopped');
                } catch (error) {
                    console.error('‚ùå Error stopping Electron audio processor:', error);
                }
            }
            
            // Á´ãÂç≥ÂÅúÊ≠¢Èü≥È¢ëÂ§ÑÁêÜ
            if (typeof audioProcessingActive !== 'undefined') {
                audioProcessingActive = false;
                console.log('üö´ Audio processing disabled');
            }
            
            if (ws && ws.readyState === WebSocket.OPEN && resampledBuffer.length > 0) {
                const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                const finalChunk = new Float32Array(targetChunkSize);
                finalChunk.set(resampledBuffer);
                try {
                    ws.send(finalChunk.buffer);
                } catch (error) {
                    console.error('Error sending final audio chunk:', error);
                }
            }
            
            if (ws) {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                } catch (e) {
                    console.error('Error closing WebSocket:', e);
                }
                ws = null;
            }
            
            if (micStream) {
                micStream.getTracks().forEach(track => {
                    track.stop();
                });
                micStream = null;
            }
            
            if (processor) {
                try {
                    processor.disconnect();
                } catch (e) {
                    console.error('Error disconnecting processor:', e);
                }
                processor = null;
            }
            
            if (audioContext) {
                try {
                    if (audioContext.state !== 'closed') {
                        audioContext.close().catch(e => {
                            console.error('Error closing audio context:', e);
                        });
                    }
                } catch (e) {
                    console.error('Error in audio context cleanup:', e);
                }
                audioContext = null;
            }
            
            resampledBuffer = new Float32Array();
            volumeLevel.style.width = '0%';
            volumeIndicator.classList.add('hidden');
            
            // Êõ¥Êñ∞UIÁä∂ÊÄÅ
            updateMicrophoneUI(false);
            
            if (isManualPause) {
                micStatus.textContent = 'Microphone paused.';
            } else {
                micStatus.textContent = '';
            }
            translationPaused = true;
            translationInitialized = false;
        }

        // System Audio Capture functionality
        async function startSystemAudioCapture() {
            try {
                if (!sessionId) {
                    updateStatus('Please load a model first', 'error');
                    return;
                }
                
                console.log('üîä Starting system audio capture...');
                updateStatus('Requesting system audio access...', 'processing');
                
                // ÈÄöËøáBlackHoleËôöÊãüÈü≥È¢ëËÆæÂ§áËé∑ÂèñÁ≥ªÁªüÈü≥È¢ë
                console.log('üîÑ Looking for BlackHole virtual audio device...');
                updateStatus('Searching for BlackHole audio device...', 'processing');
                
                // Ëé∑ÂèñÊâÄÊúâÂèØÁî®ÁöÑÈü≥È¢ëËÆæÂ§á
                const audioDevices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = audioDevices.filter(device => device.kind === 'audioinput');
                
                console.log('üîç Total audio devices found:', audioDevices.length);
                console.log('üé§ Audio input devices found:', audioInputs.length);
                console.log('üìã Available audio input devices:');
                audioInputs.forEach((device, index) => {
                    console.log(`  ${index + 1}. "${device.label || 'Unnamed Device'}" (ID: ${device.deviceId.substring(0, 20)}...)`);
                    console.log(`      Kind: ${device.kind}, GroupId: ${device.groupId ? device.groupId.substring(0, 20) + '...' : 'No Group'}`);
                });
                
                // ÂØªÊâæBlackHoleÊàñÂÖ∂‰ªñËôöÊãüÈü≥È¢ëËÆæÂ§á - Â¢ûÂº∫Ê£ÄÊµãÈÄªËæë
                console.log('üîç Searching for virtual audio devices...');
                
                const virtualDeviceCandidates = audioInputs.filter(device => {
                    const label = device.label.toLowerCase();
                    const originalLabel = device.label; // ‰øùÁïôÂéüÂßãÊ†áÁ≠æÁî®‰∫éË∞ÉËØï
                    
                    // Êõ¥ÂÖ®Èù¢ÁöÑËôöÊãüËÆæÂ§áÊ£ÄÊµã
                    const isBlackHole = label.includes('blackhole') || label.includes('black hole');
                    const isSoundFlower = label.includes('soundflower') || label.includes('sound flower');
                    const isVirtual = label.includes('virtual');
                    const isAggregate = label.includes('aggregate');
                    const isMultiOutput = label.includes('multi-output') || label.includes('multi output') || label.includes('multioutput') || label.includes('multi_output');
                    const isLoopback = label.includes('loopback');
                    const isSystem = label.includes('system') && (label.includes('audio') || label.includes('sound'));
                    
                    // ÁâπÂà´Ê£ÄÊü•ÂåÖÂê´"device"ÂÖ≥ÈîÆËØçÁöÑËÆæÂ§á
                    const isDeviceKeyword = label.includes('device') && (
                        label.includes('multi') || 
                        label.includes('aggregate') || 
                        label.includes('virtual') ||
                        label.includes('output')
                    );
                    
                    const isVirtualDevice = isBlackHole || isSoundFlower || isVirtual || isAggregate || isMultiOutput || isLoopback || isSystem || isDeviceKeyword;
                    
                    console.log(`üéß Checking device: "${originalLabel}"`, {
                        labelLower: label,
                        isBlackHole, isSoundFlower, isVirtual, isAggregate, isMultiOutput, isLoopback, isSystem, isDeviceKeyword,
                        isVirtualDevice: isVirtualDevice ? '‚úÖ YES' : '‚ùå NO'
                    });
                    
                    return isVirtualDevice;
                });
                
                console.log('üéØ Virtual device candidates found:', virtualDeviceCandidates.length);
                virtualDeviceCandidates.forEach((device, index) => {
                    console.log(`  ${index + 1}. "${device.label}" (ID: ${device.deviceId.substring(0, 20)}...)`);
                });
                
                const virtualDevice = virtualDeviceCandidates[0]; // ÈÄâÊã©Á¨¨‰∏Ä‰∏™ÂåπÈÖçÁöÑËôöÊãüËÆæÂ§á
                
                if (virtualDevice) {
                    console.log('üéØ Found virtual audio device:', virtualDevice.label);
                    updateStatus('Connecting to ' + virtualDevice.label + '...', 'processing');
                    
                    systemAudioStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: { exact: virtualDevice.deviceId },
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            channelCount: 2,
                            sampleRate: 48000
                        }
                    });
                    
                    console.log('‚úÖ System audio stream obtained from virtual device:', systemAudioStream);
                    console.log('üéØ Stream details:', {
                        active: systemAudioStream.active,
                        tracks: systemAudioStream.getTracks().length,
                        audioTracks: systemAudioStream.getAudioTracks().map(track => ({
                            label: track.label,
                            enabled: track.enabled,
                            readyState: track.readyState
                        }))
                    });
                    updateStatus('Ready - Please play any audio/video to begin translation', 'ready');
                } else {
                    // Êèê‰æõÊõ¥ËØ¶ÁªÜÁöÑËÆæÂ§áÂàóË°®ÂíåËß£ÂÜ≥ÊñπÊ°à
                    console.log('üîç All available audio input devices:');
                    audioInputs.forEach((device, index) => {
                        console.log(`  ${index + 1}. "${device.label}" (ID: ${device.deviceId.substring(0, 20)}...)`);
                    });
                    
                    const errorMessage = `Virtual audio device not found. Available options:\n\n1. Install BlackHole and create a multi-output device\n2. Use existing aggregate or virtual audio devices\n3. Create a multi-output device in Audio MIDI Setup\n\nFound ${audioInputs.length} audio input devices, but none matched virtual device patterns.`;
                    
                    console.error('‚ùå Virtual audio device not found:', errorMessage);
                    updateStatus('Virtual audio device not found. Please set up a multi-output device or install BlackHole.', 'error');
                    
                    throw new Error(errorMessage);
                }
                
                // Show translation panel
                showPanel();
                
                const wsUrl = getWebSocketUrl(sessionId);
                console.log(`Connecting to WebSocket at: ${wsUrl}`);
                
                ws = new WebSocket(wsUrl);
                
                ws.onmessage = (event) => {
                    const message = event.data;
                    console.log('WebSocket message received:', message);

                    // Â§ÑÁêÜÊéßÂà∂Ê∂àÊÅØ
                    if (typeof message === 'string' && message.startsWith('INITIALIZING:')) {
                        updateStatus(message.substring('INITIALIZING:'.length).trim(), 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('READY:')) {
                        updateStatus('Model is ready. Processing system audio...', 'processing');
                        return;
                    } else if (typeof message === 'string' && message.startsWith('ERROR:')) {
                        updateStatus(message, 'error');
                        return;
                    }
                    
                    // Â§ÑÁêÜÁøªËØëÁªìÊûú
                    if (isElectron) {
                        // Âú®ElectronÁéØÂ¢É‰∏≠Âè™Êõ¥Êñ∞Áã¨Á´ãÁøªËØëÁ™óÂè£
                        updateElectronTranslation(message);
                    } else {
                        // Âú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Êõ¥Êñ∞‰∏ªÁ™óÂè£Èù¢Êùø
                        translationOutput.textContent = message;
                        setTimeout(() => {
                            scrollTranslationToBottom();
                        }, 10);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    const errorMsg = 'WebSocket connection error';
                    updateStatus(errorMsg, 'error');
                    stopSystemAudioCapture(false);
                };
                
                ws.onopen = async () => {
                    console.log('WebSocket connected successfully for system audio');
                    
                    try {
                        // Âú®ElectronÁéØÂ¢É‰∏≠‰ΩøÁî®‰∏ìÁî®Èü≥È¢ëÂ§ÑÁêÜÂô®
                        if (isElectron && window.ElectronAudioProcessor) {
                            console.log('üéµ Using Electron-specific audio processor for system audio...');
                            
                            try {
                                // Á°Æ‰øùÊ≤°ÊúâÂÖ∂‰ªñÈü≥È¢ëÂ§ÑÁêÜÂú®ËøêË°å
                                if (audioContext) {
                                    try {
                                        await audioContext.close();
                                        audioContext = null;
                                        console.log('üßπ Closed existing AudioContext');
                                    } catch (e) {
                                        console.warn('‚ö†Ô∏è Error closing existing AudioContext:', e);
                                    }
                                }
                                
                                // Á¶ÅÁî®ÂÖ®Â±ÄÈü≥È¢ëÂ§ÑÁêÜÊ†áÂøó
                                audioProcessingActive = false;
                                
                                electronAudioProcessor = new window.ElectronAudioProcessor();
                                await electronAudioProcessor.initializeAudio(systemAudioStream, ws, 'system_audio');
                                
                                                        // ËÆæÁΩÆUIÁä∂ÊÄÅ
                        translationPaused = false;
                        translationInitialized = true;
                        
                        updateSystemAudioUI(true);
                        updateStatus('System audio connected - Play audio/video to see translation', 'ready');
                        resetIdleTimer();
                                
                                console.log('‚úÖ Electron audio processor initialized for system audio');
                                return;
                            } catch (electronError) {
                                console.error('‚ùå Electron audio processor failed for system audio:', electronError);
                                updateStatus('Electron audio processor failed, using fallback...', 'processing');
                                
                                // Ê∏ÖÁêÜÂ§±Ë¥•ÁöÑElectronÂ§ÑÁêÜÂô®
                                if (electronAudioProcessor) {
                                    try {
                                        electronAudioProcessor.stop();
                                        electronAudioProcessor = null;
                                    } catch (cleanupError) {
                                        console.error('Error cleaning up failed Electron processor:', cleanupError);
                                    }
                                }
                                
                                // ÁªßÁª≠‰ΩøÁî®‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºè‰Ωú‰∏∫Â§áÁî®ÊñπÊ°à
                                console.log('üîÑ Falling back to traditional browser audio processing...');
                            }
                        }
                        
                        // ‰º†ÁªüÊµèËßàÂô®Â§ÑÁêÜÊñπÂºè
                        console.log('Creating AudioContext for system audio...');
                        audioContext = new AudioContext();
                        console.log('AudioContext created with sample rate:', audioContext.sampleRate);
                        
                        console.log('Creating MediaStreamSource for system audio...');
                        const systemAudioSource = audioContext.createMediaStreamSource(systemAudioStream);
                        console.log('MediaStreamSource created for system audio');
                        
                        // ‰ΩøÁî®‰∏éÈ∫¶ÂÖãÈ£éÁõ∏ÂêåÁöÑÈü≥È¢ëÂ§ÑÁêÜÈÄªËæë - ÂÜÖËÅîÂ§ÑÁêÜÂô®ÂàõÂª∫
                        processor = audioContext.createScriptProcessor(segmentSize, 1, 1);
                        
                        // Ê∑ªÂä†Èü≥È¢ëÊ£ÄÊµãÊ†áÂøó
                        let hasDetectedSystemAudio = false;
                        
                        processor.onaudioprocess = (event) => {
                            const inputData = event.inputBuffer.getChannelData(0);
                            
                            // Ê£ÄÊµãÈü≥È¢ëÊ¥ªÂä®
                            let hasSound = false;
                            let volumeSum = 0;
                            for (let i = 0; i < inputData.length; i++) {
                                const volume = Math.abs(inputData[i]);
                                volumeSum += volume;
                                if (volume > 0.01) {
                                    hasSound = true;
                                }
                            }
                            
                            // È¶ñÊ¨°Ê£ÄÊµãÂà∞Èü≥È¢ëÊó∂Êõ¥Êñ∞Áä∂ÊÄÅ
                            if (hasSound && !hasDetectedSystemAudio) {
                                hasDetectedSystemAudio = true;
                                updateStatus('Processing audio from system...', 'processing');
                                console.log('üîä First audio detected from system audio device');
                            }
                            
                            // Resample to target sample rate
                            const resampleRatio = targetSampleRate / audioContext.sampleRate;
                            const resampledLength = Math.floor(inputData.length * resampleRatio);
                            const resampledChunk = new Float32Array(resampledLength);
                            for (let i = 0; i < resampledLength; i++) {
                                const originalIndex = Math.floor(i / resampleRatio);
                                resampledChunk[i] = inputData[originalIndex];
                            }
                            
                            // Add to buffer
                            const newBuffer = new Float32Array(resampledBuffer.length + resampledChunk.length);
                            newBuffer.set(resampledBuffer);
                            newBuffer.set(resampledChunk, resampledBuffer.length);
                            resampledBuffer = newBuffer;
                            
                            // Send chunks when buffer is large enough
                            const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                            while (resampledBuffer.length >= targetChunkSize) {
                                const chunk = resampledBuffer.slice(0, targetChunkSize);
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(chunk.buffer);
                                }
                                resampledBuffer = resampledBuffer.slice(targetChunkSize);
                            }
                        };
                        
                        systemAudioSource.connect(processor);
                        processor.connect(audioContext.destination);
                        
                        translationPaused = false;
                        translationInitialized = true;
                        updateSystemAudioUI(true);
                        updateStatus('System audio connected - Play audio/video to see translation', 'ready');
                        resetIdleTimer();
                        
                    } catch (audioError) {
                        console.error('Error setting up system audio processing:', audioError);
                        updateStatus('Error setting up system audio processing: ' + audioError.message, 'error');
                        stopSystemAudioCapture(false);
                    }
                };
                
            } catch (error) {
                console.error('System audio capture error:', error);
                let errorMessage = 'Error accessing system audio: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Permission denied. Please allow screen recording/audio access.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No audio source found. Please ensure you have a virtual audio device installed (like BlackHole).';
                } else {
                    errorMessage += error.message;
                }
                
                updateStatus(errorMessage, 'error');
                console.error('Full error details:', error);
            }
        }

        function updateSystemAudioUI(isCapturing) {
            if (isCapturing) {
                systemAudioBtn.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M3,9V15H7L12,20V4L7,9H3M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>
                    </svg>
                    Stop System Audio
                `;
                systemAudioBtn.classList.add('capturing');
                isSystemAudioCapturing = true;
            } else {
                systemAudioBtn.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M3,9V15H7L12,20V4L7,9H3M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>
                    </svg>
                    Capture System Audio
                `;
                systemAudioBtn.classList.remove('capturing');
                isSystemAudioCapturing = false;
            }
        }

        function stopSystemAudioCapture(isManualPause = false) {
            console.log('üõë Stopping system audio capture...');
            
            // Â¶ÇÊûú‰ΩøÁî®ElectronÈü≥È¢ëÂ§ÑÁêÜÂô®Ôºå‰ºòÂÖàÂÅúÊ≠¢ÂÆÉ
            if (electronAudioProcessor) {
                console.log('üßπ Stopping Electron audio processor...');
                try {
                    electronAudioProcessor.stop();
                    electronAudioProcessor = null;
                    console.log('‚úÖ Electron audio processor stopped');
                } catch (error) {
                    console.error('‚ùå Error stopping Electron audio processor:', error);
                }
            }
            
            // Á´ãÂç≥ÂÅúÊ≠¢Èü≥È¢ëÂ§ÑÁêÜ
            if (typeof audioProcessingActive !== 'undefined') {
                audioProcessingActive = false;
                console.log('üö´ Audio processing disabled');
            }
            
            if (ws && ws.readyState === WebSocket.OPEN && resampledBuffer.length > 0) {
                const targetChunkSize = baseChunkSize * currentLatencyMultiplier;
                const finalChunk = new Float32Array(targetChunkSize);
                finalChunk.set(resampledBuffer);
                try {
                    ws.send(finalChunk.buffer);
                } catch (error) {
                    console.error('Error sending final audio chunk:', error);
                }
            }
            
            if (ws) {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                } catch (e) {
                    console.error('Error closing WebSocket:', e);
                }
                ws = null;
            }
            
            if (systemAudioStream) {
                systemAudioStream.getTracks().forEach(track => {
                    track.stop();
                });
                systemAudioStream = null;
            }
            
            if (processor) {
                try {
                    processor.disconnect();
                } catch (e) {
                    console.error('Error disconnecting processor:', e);
                }
                processor = null;
            }
            
            if (audioContext) {
                try {
                    if (audioContext.state !== 'closed') {
                        audioContext.close().catch(e => {
                            console.error('Error closing audio context:', e);
                        });
                    }
                } catch (e) {
                    console.error('Error in audio context cleanup:', e);
                }
                audioContext = null;
            }
            
            resampledBuffer = new Float32Array();
            
            // Êõ¥Êñ∞UIÁä∂ÊÄÅ
            updateSystemAudioUI(false);
            
            if (isManualPause) {
                updateStatus('System audio capture stopped.', 'ready');
            } else {
                updateStatus('', 'ready');
            }
            translationPaused = true;
            translationInitialized = false;
        }

        // Reset translation
        resetTranslation.addEventListener('click', async () => {
            if (!sessionId) return;
            
            try {
                if (isMicRecording) {
                    stopMicrophone(false);
                } else if (isSystemAudioCapturing) {
                    stopSystemAudioCapture(false);
                } else {
                    volumeLevel.style.width = '0%';
                    volumeIndicator.classList.add('hidden');
                    micStatus.textContent = '';
                }
                
                cleanupAudioResources();
                
                if (audioContext) {
                    try {
                        if (audioContext.state !== 'closed') {
                            await audioContext.close();
                        }
                        audioContext = null;
                    } catch (e) {
                        console.error('Error closing AudioContext:', e);
                    }
                }
                
                audioElementConnected = false;
                
                // Reset media container
                const existingMedia = mediaContainer.querySelector('audio, video');
                if (existingMedia) {
                    existingMedia.remove();
                }
                
                const placeholder = mediaContainer.querySelector('.video-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                
                currentMediaElement = null;
                
                if (audioFile) {
                    audioFile.value = '';
                }
                
                if (youtubeUrl) {
                    youtubeUrl.value = '';
                }
                
                volumeLevel.style.width = '0%';
                volumeIndicator.classList.add('hidden');
                translationInitialized = false;
                
                const response = await fetch('/reset_translation?' + new URLSearchParams({
                    session_id: sessionId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    if (!isElectron) {
                        // Âè™Âú®ÈùûElectronÁéØÂ¢É‰∏ãÊõ¥Êñ∞‰∏ªÁ™óÂè£Èù¢Êùø
                        translationOutput.textContent = 'Translation will appear here...';
                    }
                    updateStatus(data.message || 'Translation reset successfully. Please select an audio source.', 'ready');
                    updateLatency.disabled = false;
                    console.log('Translation reset successfully');
                } else {
                    updateStatus('Failed to reset translation: ' + data.error, 'error');
                    console.error('Failed to reset translation:', data.error);
                }
            } catch (error) {
                updateStatus('Error resetting translation: ' + error, 'error');
                console.error('Error resetting translation:', error);
            }
        });

        // Update latency
        updateLatency.addEventListener('click', async () => {
            if (!sessionId) return;
            
            try {
                currentLatencyMultiplier = parseInt(latencyMultiplier.value);
                const response = await fetch('/update_latency?' + new URLSearchParams({
                    session_id: sessionId,
                    latency_multiplier: currentLatencyMultiplier
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    updateStatus('Latency updated successfully', 'ready');
                    console.log('Latency updated to:', latencyMultiplier.value + 'x');
                } else {
                    updateStatus('Failed to update latency: ' + data.error, 'error');
                    console.error('Failed to update latency:', data.error);
                }
            } catch (error) {
                updateStatus('Error updating latency: ' + error, 'error');
                console.error('Error updating latency:', error);
            }
        });

        // ‰æõElectronË∞ÉÁî®ÁöÑÈáçÁΩÆÁøªËØëÂáΩÊï∞
        window.resetTranslationFromElectron = async function() {
            if (!sessionId) return;
            
            try {
                if (isMicRecording) {
                    stopMicrophone(false);
                } else if (isSystemAudioCapturing) {
                    stopSystemAudioCapture(false);
                } else {
                    volumeLevel.style.width = '0%';
                    volumeIndicator.classList.add('hidden');
                    micStatus.textContent = '';
                }
                
                cleanupAudioResources();
                
                if (audioContext) {
                    try {
                        if (audioContext.state !== 'closed') {
                            await audioContext.close();
                        }
                        audioContext = null;
                    } catch (e) {
                        console.error('Error closing AudioContext:', e);
                    }
                }
                
                audioElementConnected = false;
                
                // Reset media container
                const existingMedia = mediaContainer.querySelector('audio, video');
                if (existingMedia) {
                    existingMedia.remove();
                }
                
                const placeholder = mediaContainer.querySelector('.video-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                
                currentMediaElement = null;
                
                if (audioFile) {
                    audioFile.value = '';
                }
                
                if (youtubeUrl) {
                    youtubeUrl.value = '';
                }
                
                volumeLevel.style.width = '0%';
                volumeIndicator.classList.add('hidden');
                translationInitialized = false;
                
                const response = await fetch('/reset_translation?' + new URLSearchParams({
                    session_id: sessionId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    updateStatus(data.message || 'Translation reset successfully. Please select an audio source.', 'ready');
                    updateLatency.disabled = false;
                    console.log('Translation reset successfully from Electron');
                } else {
                    updateStatus('Failed to reset translation: ' + data.error, 'error');
                    console.error('Failed to reset translation:', data.error);
                }
            } catch (error) {
                updateStatus('Error resetting translation: ' + error, 'error');
                console.error('Error resetting translation:', error);
            }
        };

        // ÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜÔºåÈò≤Ê≠¢ÁôΩÂ±è
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', event.error);
            if (isElectron) {
                updateElectronStatus('Error: ' + event.error.message, 'error');
            } else {
                // Â∞ùËØïÊÅ¢Â§çUIÁä∂ÊÄÅ
                try {
                    updateStatus('Application error occurred: ' + event.error.message, 'error');
                } catch (e) {
                    console.error('Error in error handler:', e);
                }
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            if (isElectron) {
                updateElectronStatus('Error: ' + event.reason, 'error');
            } else {
                try {
                    updateStatus('Promise rejection: ' + event.reason, 'error');
                } catch (e) {
                    console.error('Error in rejection handler:', e);
                }
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // ElectronÁéØÂ¢É‰∏ãÂº∫Âà∂Ë∞ÉÊï¥ÊåâÈíÆ‰ΩçÁΩÆÂíåUIÂàáÊç¢
                if (typeof window !== 'undefined' && window.electronAPI) {
                    console.log('üîÑ DOMContentLoaded: Re-applying Electron mode UI...');
                    
                    // Á´ãÂç≥ÊâßË°åÂº∫Âà∂UIÂàáÊç¢
                    forceElectronModeUI();
                    
                    setTimeout(() => {
                        const buttonsGroup = document.querySelector('.buttons-group');
                        if (buttonsGroup) {
                            buttonsGroup.style.transform = 'translateY(-25px)';
                            buttonsGroup.style.position = 'relative';
                            buttonsGroup.style.zIndex = '10';
                            console.log('Electron: ÊåâÈíÆ‰ΩçÁΩÆÂ∑≤Ë∞ÉÊï¥Âà∞-25px');
                        }
                        
                        // ÂÜçÊ¨°Âº∫Âà∂ÊâßË°åUIÂàáÊç¢ÔºåÈò≤Ê≠¢‰ªª‰ΩïÊó∂Â∫èÈóÆÈ¢ò
                        console.log('üîÑ DOMContentLoaded: Final UI enforcement...');
                        forceElectronModeUI();
                        
                    }, 100);
                }
                
                ensureClientId();
                
                // Âè™Âú®ÈùûElectronÁéØÂ¢É‰∏ãÂàùÂßãÂåñÈù¢ÊùøÊãñÊãΩ
                if (!isElectron) {
                    initializePanelDragging();
                }
                
                const userEvents = ['mousedown', 'keypress', 'scroll', 'touchstart'];
                userEvents.forEach(eventType => {
                    document.addEventListener(eventType, resetIdleTimer);
                });
                
                resetIdleTimer();
                
                const storedSessionId = localStorage.getItem('translationSessionId_' + clientId);
                if (storedSessionId) {
                    console.log('Found stored session ID:', storedSessionId);
                    checkSessionStatus(storedSessionId);
                } else {
                    console.log('No stored session found, starting fresh');
                }
                
                const pendingDeleteSessions = JSON.parse(localStorage.getItem('pendingDeleteSessions_' + clientId) || '{}');
                if (Object.keys(pendingDeleteSessions).length > 0) {
                    console.log(`Found ${Object.keys(pendingDeleteSessions).length} orphaned sessions to delete`);
                    // Add session cleanup logic here if needed
                }
            } catch (error) {
                console.error('Error during initialization:', error);
                if (isElectron) {
                    updateElectronStatus('Init error: ' + error.message, 'error');
                }
            }
        });

        async function checkSessionStatus(checkSessionId) {
            try {
                const response = await fetch('/delete_session?' + new URLSearchParams({
                    session_id: checkSessionId
                }), {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    console.log('Session exists and was deleted:', checkSessionId);
                    localStorage.removeItem('translationSessionId_' + clientId);
                } else if (data.error && data.error.includes('Invalid session ID')) {
                    console.log('Stored session no longer exists:', checkSessionId);
                    localStorage.removeItem('translationSessionId_' + clientId);
                } else {
                    console.error('Unexpected error checking session:', data.error);
                    localStorage.removeItem('translationSessionId_' + clientId);
                }
            } catch (error) {
                console.error('Error checking session status:', error);
                localStorage.removeItem('translationSessionId_' + clientId);
            }
        }

        // ToastÈÄöÁü•Á≥ªÁªüÂ∑≤ÁßªÈô§
        
        // Êõ¥Êñ∞ElectronÁä∂ÊÄÅÊ†è
        function updateElectronStatusBar(text, type = 'ready') {
            const statusBar = document.getElementById('electronStatusBar');
            const statusIcon = document.getElementById('electronStatusIcon');
            const statusText = document.getElementById('electronStatusText');
            
            if (statusBar && statusIcon && statusText) {
                // Êõ¥Êñ∞Áä∂ÊÄÅÊ†èÊ†∑Âºè
                statusBar.className = `electron-status-bar ${type}`;
                statusIcon.className = `electron-status-icon ${type}`;
                statusText.textContent = text;
            }
        }
    </script>
</body>
</html> 